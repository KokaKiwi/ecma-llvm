%token_prefix       ECMA_TOKEN_TYPE_
%token_type         { lex::Token * }
%extra_argument     { parser::Parser *parser }
%name               ecma_parse

%include
{
    #include <cassert>
    #include <cstdio>
    #include <memory>
    #include <vector>
    #include <string>
    #include "ecma/lex/token.h"
    #include "ecma/parser/parser.h"
    #include "ecma/parser/error.h"
    #include "ecma/utils/messages.h"

    #include "ecma/ast/ast.h"

    using namespace ecma;
    using namespace ecma::ast;
}

%syntax_error {
    parser::ParsingError error("Unexpected token: {token}", TOKEN);
    utils::Messages::ReportError(error.message(), TOKEN->pos(), TOKEN->length() > 0 ? TOKEN->length() - 1 : 0);
}

%left INSTANCEOF CONTINUE DEBUGGER FUNCTION DEFAULT FINALLY DELETE RETURN SWITCH TYPEOF BREAK CATCH THROW WHILE CASE THIS VOID WITH FOR GET NEW SET TRY VAR DO IN.
%right ELSE IF.
%left EXTENDS EXPORT IMPORT CLASS CONST SUPER ENUM.
%left IMPLEMENTS INTERFACE PROTECTED PACKAGE PRIVATE PUBLIC STATIC YIELD LET.
%left ZERO_RIGHT_SHIFT_ASSIGN STRICT_EQUAL STRICT_NOT_EQUAL ZERO_RIGHT_SHIFT LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN LESSER_EQ GREATER_EQ EQUAL NOT_EQUAL INCREMENT DECREMENT LEFT_SHIFT RIGHT_SHIFT LOGIC_AND LOGIC_OR PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET DOT SEMICOLON COMMA QUESTION COLON LESSER GREATER PLUS MINUS MUL MOD DIV BITWISE_AND BITWISE_OR BITWISE_XOR ASSIGN NOT INV.
%left LIT_FALSE LIT_NULL LIT_TRUE.
%left REGEXP STRING NUMBER IDENT.

/* Rule 'module' */
%start_symbol module

module ::= .
{
}

module ::= source_elements(A).
{
    for (auto it = A->begin(); it != A->end(); ++it)
    {
        parser->module()->statements().push_back(std::move(*it));
    }

    delete A;
}

/* Rule 'ident' */
%type ident { expr::Ident * }

ident(A) ::= IDENT(B).
{
    A = new expr::Ident(B->text());
    A->element(B);

    delete B;
}

ident(A) ::= SET(B).
{
    A = new expr::Ident(B->text());
    A->element(B);

    delete B;
}

ident(A) ::= GET(B).
{
    A = new expr::Ident(B->text());
    A->element(B);

    delete B;
}

/* Rule 'function_decl' */
%type function_decl { stmt::decl::Function * }

function_decl(A) ::= FUNCTION(B) ident(C) LPAREN(F) RPAREN(G) LBRACE(H) function_body(D) RBRACE(E).
{
    auto func = new expr::Function(C->name());

    for (auto it = D->begin(); it != D->end(); ++it)
    {
        func->body().push_back(std::move(*it));
    }

    A = new stmt::decl::Function(func);
    A->element(B, E);

    delete B;
    delete C;
    delete F;
    delete G;
    delete H;
    delete D;
    delete E;
}

function_decl(A) ::= FUNCTION(B) ident(C) LPAREN(G) formal_params(D) RPAREN(H) LBRACE(I) function_body(E) RBRACE(F).
{
    auto func = new expr::Function(C->name());

    for (auto it = D->begin(); it != D->end(); ++it)
    {
        func->args().push_back(*it);
    }

    for (auto it = E->begin(); it != E->end(); ++it)
    {
        func->body().push_back(std::move(*it));
    }

    A = new stmt::decl::Function(func);
    A->element(B, F);

    delete B;
    delete C;
    delete G;
    delete D;
    delete H;
    delete I;
    delete E;
    delete F;
}

/* Rule 'function_expr' */
%type function_expr { expr::Function * }

function_expr(A) ::= FUNCTION(B) ident(C) LPAREN(F) RPAREN(G) LBRACE(H) function_body(D) RBRACE(E).
{
    A = new expr::Function(C->name());

    for (auto it = D->begin(); it != D->end(); ++it)
    {
        A->body().push_back(std::move(*it));
    }

    A->element(B, E);

    delete B;
    delete C;
    delete F;
    delete G;
    delete H;
    delete D;
    delete E;
}

function_expr(A) ::= FUNCTION(B) ident(C) LPAREN(G) formal_params(D) RPAREN(H) LBRACE(I) function_body(E) RBRACE(F).
{
    A = new expr::Function(C->name());
    A->args().insert(A->args().end(), D->begin(), D->end());

    for (auto it = E->begin(); it != E->end(); ++it)
    {
        A->body().push_back(std::move(*it));
    }

    A->element(B, F);

    delete D;
    delete E;

    delete B;
    delete C;
    delete G;
    delete H;
    delete I;
    delete F;
}

function_expr(A) ::= FUNCTION(B) LPAREN(E) RPAREN(F) LBRACE(G) function_body(C) RBRACE(D).
{
    A = new expr::Function("");

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->body().push_back(std::move(*it));
    }

    A->element(B, D);

    delete C;

    delete B;
    delete E;
    delete F;
    delete G;
    delete D;
}

function_expr(A) ::= FUNCTION(B) LPAREN(F) formal_params(C) RPAREN(G) LBRACE(H) function_body(D) RBRACE(E).
{
    A = new expr::Function("");
    A->args().insert(A->args().end(), C->begin(), C->end());

    for (auto it = D->begin(); it != D->end(); ++it)
    {
        A->body().push_back(std::move(*it));
    }

    A->element(B, E);

    delete C;
    delete D;

    delete B;
    delete F;
    delete G;
    delete H;
    delete E;
}

/* Rule 'formal_params' */
%type formal_params { std::vector<std::string> * }

formal_params(A) ::= ident(B).
{
    A = new std::vector<std::string>();
    A->push_back(B->name());

    delete B;
}

formal_params(A) ::= formal_params(B) COMMA(D) ident(C).
{
    A = B;
    A->push_back(C->name());

    delete D;
    delete C;
}

/* Rule 'function_body' */
%type function_body { std::vector<std::unique_ptr<Statement>> * }

function_body(A) ::= .
{
    A = new std::vector<std::unique_ptr<Statement>>();
}

function_body(A) ::= source_elements(B).
{
    A = B;
}

/* Rule 'source_elements' */
%type source_elements { std::vector<std::unique_ptr<Statement>> * }

source_elements(A) ::= source_element(B).
{
    A = new std::vector<std::unique_ptr<Statement>>();
    A->push_back(std::unique_ptr<Statement>(B));
}

source_elements(A) ::= source_elements(B) source_element(C).
{
    A = B;
    A->push_back(std::unique_ptr<Statement>(C));
}

/* Rule 'source_element' */
%type source_element { Statement * }

source_element(A) ::= stmt(B).
{
    A = B;
}

source_element(A) ::= function_decl(B).
{
    A = B;
}

/* Rule 'stmt' */
%type stmt { Statement * }

stmt(A) ::= block(B).
{
    A = B;
}

stmt(A) ::= var_stmt(B).
{
    A = B;
}

stmt(A) ::= empty_stmt.
{
    A = new Statement();
}

stmt(A) ::= expr_stmt(B).
{
    A = B;
}

stmt(A) ::= if_stmt(B).
{
    A = B;
}

stmt(A) ::= iter_stmt(B).
{
    A = B;
}

stmt(A) ::= cont_stmt(B).
{
    A = B;
}

stmt(A) ::= break_stmt(B).
{
    A = B;
}

stmt(A) ::= return_stmt(B).
{
    A = B;
}

stmt(A) ::= with_stmt(B).
{
    A = B;
}

stmt(A) ::= switch_stmt(B).
{
    A = B;
}

stmt(A) ::= throw_stmt(B).
{
    A = B;
}

stmt(A) ::= try_stmt(B).
{
    A = B;
}

stmt(A) ::= debug_stmt(B).
{
    A = B;
}

/* Rule 'block' */
%type block { stmt::Block * }

block(A) ::= LBRACE(B) stmt_list(C) RBRACE(D).
{
    A = new stmt::Block();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->statements().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'block_empty' */
%type block_empty { stmt::Block * }

block_empty(A) ::= LBRACE(B) RBRACE(C).
{
    A = new stmt::Block();
    A->element(B, C);

    delete B;
    delete C;
}

/* Rule 'block_stmt' */
%type block_stmt { stmt::Block * }

block_stmt(A) ::= block(B).
{
    A = B;
}

block_stmt(A) ::= block_empty(B).
{
    A = B;
}

/* Rule 'stmt_list' */
%type stmt_list { std::vector<std::unique_ptr<Statement>> * }

stmt_list(A) ::= stmt(B).
{
    A = new std::vector<std::unique_ptr<Statement>>();
    A->push_back(std::unique_ptr<Statement>(B));
}

stmt_list(A) ::= stmt_list(B) stmt(C).
{
    A = B;
    A->push_back(std::unique_ptr<Statement>(C));
}

/* Rule 'var_stmt' */
%type var_stmt { stmt::decl::Vars * }

var_stmt(A) ::= VAR(B) var_decls(C) SEMICOLON(D).
{
    A = new stmt::decl::Vars();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->decls().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'var_decls' */
%type var_decls { std::vector<std::unique_ptr<stmt::decl::Var>> * }

var_decls(A) ::= var_decl(B).
{
    A = new std::vector<std::unique_ptr<stmt::decl::Var>>();
    A->push_back(std::unique_ptr<stmt::decl::Var>(B));
}

var_decls(A) ::= var_decls(B) COMMA(D) var_decl(C).
{
    A = B;
    A->push_back(std::unique_ptr<stmt::decl::Var>(C));

    delete D;
}

/* Rule 'var_decls_no_in' */
%type var_decls_no_in { std::vector<std::unique_ptr<stmt::decl::Var>> * }

var_decls_no_in(A) ::= var_decl_no_in(B).
{
    A = new std::vector<std::unique_ptr<stmt::decl::Var>>();
    A->push_back(std::unique_ptr<stmt::decl::Var>(B));
}

var_decls_no_in(A) ::= var_decls_no_in(B) COMMA(D) var_decl_no_in(C).
{
    A = B;
    A->push_back(std::unique_ptr<stmt::decl::Var>(C));

    delete D;
}

/* Rule 'var_decl' */
%type var_decl { stmt::decl::Var * }

var_decl(A) ::= ident(B).
{
    A = new stmt::decl::Var(B->name());
    A->element(B);

    delete B;
}

var_decl(A) ::= ident(B) init(C).
{
    A = new stmt::decl::Var(B->name());
    A->init(C);
    A->element(B, C);

    delete B;
}

/* Rule 'var_decl_no_in' */
%type var_decl_no_in { stmt::decl::Var * }

var_decl_no_in(A) ::= ident(B).
{
    A = new stmt::decl::Var(B->name());
    A->element(B);

    delete B;
}

var_decl_no_in(A) ::= ident(B) init_no_in(C).
{
    A = new stmt::decl::Var(B->name());
    A->init(C);
    A->element(B, C);

    delete B;
}

/* Rule 'init' */
%type init { Expression * }

init(A) ::= ASSIGN(C) assign_expr(B).
{
    A = B;

    delete C;
}

/* Rule 'init_no_in' */
%type init_no_in { Expression * }

init_no_in(A) ::= ASSIGN(C) assign_expr_no_in(B).
{
    A = B;

    delete C;
}

/* Rule 'empty_stmt' */

empty_stmt ::= SEMICOLON(A).
{
    delete A;
}

/* Rule 'expr_stmt' */
%type expr_stmt { stmt::ExpressionStmt * }

expr_stmt(A) ::= expr_no_fn(B) SEMICOLON(C).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B, C);

    delete C;
}

/* Rule 'if_stmt' */
%type if_stmt { stmt::ctrl::If * }

if_stmt(A) ::= IF(B) LPAREN(E) expr(C) RPAREN(F) stmt(D).
{
    A = new stmt::ctrl::If(C, D);
    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

if_stmt(A) ::= IF(B) LPAREN(F) expr(C) RPAREN(G) stmt(D) ELSE(H) stmt(E).
{
    A = new stmt::ctrl::If(C, D);
    A->else_stmt(E);
    A->element(B, E);

    delete B;
    delete F;
    delete G;
    delete H;
}

/* Rule 'iter_stmt' */
%type iter_stmt { Statement * }

iter_stmt(A) ::= while_stmt(B).
{
    A = B;
}

iter_stmt(A) ::= for_stmt(B).
{
    A = B;
}

iter_stmt(A) ::= for_in_stmt(B).
{
    A = B;
}

/* Rule 'while_stmt' */
%type while_stmt { stmt::ctrl::While * }

while_stmt(A) ::= WHILE(B) LPAREN(E) expr(C) RPAREN(F) stmt(D).
{
    A = new stmt::ctrl::While(false, C, D);
    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

while_stmt(A) ::= DO(B) stmt(C) WHILE(F) LPAREN(G) expr(D) RPAREN(E).
{
    A = new stmt::ctrl::While(true, D, C);
    A->element(B, E);

    delete B;
    delete F;
    delete G;
    delete E;
}

/* Rule 'for_stmt' */
%type for_stmt { stmt::ctrl::For * }

for_stmt(A) ::= FOR(B) LPAREN(G) for_init(C) SEMICOLON(H) for_cond(D) SEMICOLON(I) for_loop(E) RPAREN(J) stmt(F).
{
    A = new stmt::ctrl::For(C, D, E, F);
    A->element(B, F);

    delete B;
    delete G;
    delete H;
    delete I;
    delete J;
}

/* Rule 'for_init' */
%type for_init { Statement * }

for_init(A) ::= .
{
    A = nullptr;
}

for_init(A) ::= expr_no_in(B).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B);
}

for_init(A) ::= VAR(C) var_decls_no_in(B).
{
    auto vars = new stmt::decl::Vars();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        vars->decls().push_back(std::move(*it));
    }

    A = vars;

    delete C;
    delete B;
}

/* Rule 'for_cond' */
%type for_cond { Statement * }

for_cond(A) ::= .
{
    A = nullptr;
}

for_cond(A) ::= expr(B).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B);
}

/* Rule 'for_loop' */
%type for_loop { Statement * }

for_loop(A) ::= .
{
    A = nullptr;
}

for_loop(A) ::= expr(B).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B);
}

/* Rule 'for_in_stmt' */
%type for_in_stmt { stmt::ctrl::ForIn * }

for_in_stmt(A) ::= FOR(B) LPAREN(F) left_hand_expr(C) IN(G) expr(D) RPAREN(H) stmt(E).
{
    A = new stmt::ctrl::ForIn(C, D, E);
    A->element(B, E);

    delete B;
    delete F;
    delete G;
    delete H;
}

for_in_stmt(A) ::= FOR(B) LPAREN(F) VAR(G) var_decl_no_in(C) IN(H) expr(D) RPAREN(I) stmt(E).
{
    A = new stmt::ctrl::ForIn(new expr::Ident(C->name()), D, E);
    A->init(C->take_init());
    A->element(B, E);

    delete C;

    delete B;
    delete F;
    delete G;
    delete H;
    delete I;
}

/* Rule 'cont_stmt' */
%type cont_stmt { stmt::ctrl::Continue * }

cont_stmt(A) ::= CONTINUE(B) SEMICOLON(C).
{
    A = new stmt::ctrl::Continue();
    A->element(B, C);

    delete B;
    delete C;
}

cont_stmt(A) ::= CONTINUE(B) ident(C) SEMICOLON(D).
{
    A = new stmt::ctrl::Continue();
    A->name(C->name());
    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'break_stmt' */
%type break_stmt { stmt::ctrl::Break * }

break_stmt(A) ::= BREAK(B) SEMICOLON(C).
{
    A = new stmt::ctrl::Break();
    A->element(B, C);

    delete B;
    delete C;
}

break_stmt(A) ::= BREAK(B) ident(C) SEMICOLON(D).
{
    A = new stmt::ctrl::Break();
    A->name(new std::string(C->name()));
    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'return_stmt' */
%type return_stmt { stmt::ctrl::Return * }

return_stmt(A) ::= RETURN(B) SEMICOLON(C).
{
    A = new stmt::ctrl::Return();
    A->element(B, C);

    delete B;
    delete C;
}

return_stmt(A) ::= RETURN(B) expr(C) SEMICOLON(D).
{
    A = new stmt::ctrl::Return();
    A->expr(C);
    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'with_stmt' */
%type with_stmt { stmt::ctrl::With * }

with_stmt(A) ::= WITH(B) LPAREN(E) expr(C) RPAREN(F) stmt(D).
{
    A = new stmt::ctrl::With(C, D);
    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

/* Rule 'switch_stmt' */
%type switch_stmt { stmt::ctrl::Switch * }

switch_stmt(A) ::= SWITCH(B) LPAREN(E) expr(C) RPAREN(F) case_block(D).
{
    A = new stmt::ctrl::Switch(C);

    for (auto it = D->cases().begin(); it != D->cases().end(); ++it)
    {
        A->cases().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete E;
    delete F;
    delete D;
}

/* Rule 'case_block' */
%type case_block { stmt::ctrl::CaseBlock * }

case_block(A) ::= LBRACE(B) RBRACE(C).
{
    A = new stmt::ctrl::CaseBlock();

    delete B;
    delete C;
}

case_block(A) ::= LBRACE(B) case_clauses(C) RBRACE(D).
{
    A = new stmt::ctrl::CaseBlock();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->cases().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'case_clauses' */
%type case_clauses { std::vector<std::unique_ptr<stmt::ctrl::Case>> * }

case_clauses(A) ::= case_clause(B).
{
    A = new std::vector<std::unique_ptr<stmt::ctrl::Case>>();
    A->push_back(std::unique_ptr<stmt::ctrl::Case>(B));
}

case_clauses(A) ::= case_clauses(B) case_clause(C).
{
    A = B;
    A->push_back(std::unique_ptr<stmt::ctrl::Case>(C));
}

/* Rule 'case_clause' */
%type case_clause { stmt::ctrl::Case * }

case_clause(A) ::= case_key(B) COLON(C).
{
    A = new stmt::ctrl::Case(B);
    A->element(B, C);

    delete C;
}

case_clause(A) ::= case_key(B) COLON(D) stmt_list(C).
{
    A = new stmt::ctrl::Case(B);

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->actions().push_back(std::move(*it));
    }

    delete D;
    delete C;
}

/* Rule 'case_key' */
%type case_key { stmt::ctrl::CaseKey * }

case_key(A) ::= CASE(B) expr(C).
{
    A = new stmt::ctrl::CaseKey();
    A->expr(C);
    A->element(B, C);

    delete B;
}

case_key(A) ::= DEFAULT(B).
{
    A = new stmt::ctrl::CaseKey();
    A->element(B);

    delete B;
}

/* Rule 'throw_stmt' */
%type throw_stmt { stmt::ctrl::Throw * }

throw_stmt(A) ::= THROW(B) expr(C) SEMICOLON(D).
{
    A = new stmt::ctrl::Throw(C);
    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'try_stmt' */
%type try_stmt { stmt::ctrl::Try * }

try_stmt(A) ::= TRY(B) block_stmt(C) catch(D).
{
    A = new stmt::ctrl::Try(C);
    A->catch_action(D);
    A->element(B, D);

    delete B;
}

try_stmt(A) ::= TRY(B) block_stmt(C) finally(D).
{
    A = new stmt::ctrl::Try(C);
    A->finally_action(D);
    A->element(B, D);

    delete B;
}

try_stmt(A) ::= TRY(B) block_stmt(C) catch(D) finally(E).
{
    A = new stmt::ctrl::Try(C);
    A->catch_action(D);
    A->finally_action(E);
    A->element(B, E);

    delete B;
}

/* Rule 'catch' */
%type catch { stmt::ctrl::Catch * }

catch(A) ::= CATCH(B) LPAREN(E) ident(C) RPAREN(F) block_stmt(D).
{
    A = new stmt::ctrl::Catch(C->name(), D);
    A->element(B, D);

    delete B;
    delete E;
    delete C;
    delete F;
}

/* Rule 'finally' */
%type finally { stmt::ctrl::Finally * }

finally(A) ::= FINALLY(B) block_stmt(C).
{
    A = new stmt::ctrl::Finally(C);
    A->element(B, C);

    delete B;
}

/* Rule 'debug_stmt' */
%type debug_stmt { stmt::Debug * }

debug_stmt(A) ::= DEBUGGER(B) SEMICOLON(C).
{
    A = new stmt::Debug();
    A->element(B, C);

    delete B;
    delete C;
}

/* Rule 'primary_expr' */
%type primary_expr { Expression * }

primary_expr(A) ::= THIS(B).
{
    A = new expr::This();
    A->element(B);

    delete B;
}

primary_expr(A) ::= ident(B).
{
    A = B;
    A->element(B);
}

primary_expr(A) ::= literal(B).
{
    A = B;
}

primary_expr(A) ::= array(B).
{
    A = B;
}

primary_expr(A) ::= object(B).
{
    A = B;
}

primary_expr(A) ::= LPAREN(C) expr(B) RPAREN(D).
{
    A = B;

    delete C;
    delete D;
}

/* Rule 'member_expr' */
%type member_expr { Expression * }

member_expr(A) ::= primary_expr(B).
{
    A = B;
}

member_expr(A) ::= function_expr(B).
{
    A = B;
}

member_expr(A) ::= member_expr(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

member_expr(A) ::= member_expr(B) DOT(D) ident(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->name());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

member_expr(A) ::= NEW(B) member_expr(C) arguments(D).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    for(auto it = D->elements().begin(); it != D->elements().end(); ++it)
    {
        new_expr->args().push_back(std::move(*it));
    }

    A = new_expr;
    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'member_expr_no_fn' */
%type member_expr_no_fn { Expression * }

member_expr_no_fn(A) ::= primary_expr(B).
{
    A = B;
}

member_expr_no_fn(A) ::= member_expr_no_fn(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

member_expr_no_fn(A) ::= member_expr_no_fn(B) DOT(D) ident(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->name());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

member_expr_no_fn(A) ::= NEW(B) member_expr(C) arguments(D).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    for(auto it = D->elements().begin(); it != D->elements().end(); ++it)
    {
        new_expr->args().push_back(std::move(*it));
    }

    A = new_expr;
    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'new_expr' */
%type new_expr { Expression * }

new_expr(A) ::= member_expr(B).
{
    A = B;
}

new_expr(A) ::= NEW(B) new_expr(C).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    A = new_expr;
    A->element(B, C);

    delete B;
}

/* Rule 'new_expr_no_fn' */
%type new_expr_no_fn { Expression * }

new_expr_no_fn(A) ::= member_expr_no_fn(B).
{
    A = B;
}

new_expr_no_fn(A) ::= NEW(B) new_expr(C).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    A = new_expr;
    A->element(B, C);

    delete B;
}

/* Rule 'call_expr' */
%type call_expr { Expression * }

call_expr(A) ::= member_expr(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);

    delete C;
}

call_expr(A) ::= call_expr(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);

    delete C;
}

call_expr(A) ::= call_expr(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

call_expr(A) ::= call_expr(B) DOT(D) ident(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->name());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

/* Rule 'call_expr_no_fn' */
%type call_expr_no_fn { Expression * }

call_expr_no_fn(A) ::= member_expr_no_fn(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);

    delete C;
}

call_expr_no_fn(A) ::= call_expr_no_fn(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);

    delete C;
}

call_expr_no_fn(A) ::= call_expr_no_fn(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

call_expr_no_fn(A) ::= call_expr_no_fn(B) DOT(D) ident(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->name());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

/* Rule 'left_hand_expr' */
%type left_hand_expr { Expression * }

left_hand_expr(A) ::= new_expr(B).
{
    A = B;
}

left_hand_expr(A) ::= call_expr(B).
{
    A = B;
}

/* Rule 'left_hand_expr_no_fn' */
%type left_hand_expr_no_fn { Expression * }

left_hand_expr_no_fn(A) ::= new_expr_no_fn(B).
{
    A = B;
}

left_hand_expr_no_fn(A) ::= call_expr_no_fn(B).
{
    A = B;
}

/* Rule 'postfix_expr' */
%type postfix_expr { Expression * }

postfix_expr(A) ::= left_hand_expr(B).
{
    A = B;
}

postfix_expr(A) ::= left_hand_expr(B) INCREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::INCREMENT);
    A->element(B, C);

    delete C;
}

postfix_expr(A) ::= left_hand_expr(B) DECREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::DECREMENT);
    A->element(B, C);

    delete C;
}

/* Rule 'postfix_expr_no_fn' */
%type postfix_expr_no_fn { Expression * }

postfix_expr_no_fn(A) ::= left_hand_expr_no_fn(B).
{
    A = B;
}

postfix_expr_no_fn(A) ::= left_hand_expr_no_fn(B) INCREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::INCREMENT);
    A->element(B, C);

    delete C;
}

postfix_expr_no_fn(A) ::= left_hand_expr_no_fn(B) DECREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::DECREMENT);
    A->element(B, C);

    delete C;
}

/* Rule 'unary_expr' */
%type unary_expr { Expression * }

unary_expr(A) ::= postfix_expr(B).
{
    A = B;
}

unary_expr(A) ::= DELETE(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DELETE);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= VOID(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::VOID);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= TYPEOF(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::TYPEOF);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= INCREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INCREMENT);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= DECREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DECREMENT);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= PLUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::PLUS);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= MINUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::MINUS);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= INV(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INV);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= NOT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::NOT);
    A->element(B, C);

    delete B;
}

/* Rule 'unary_expr_no_fn' */
%type unary_expr_no_fn { Expression * }

unary_expr_no_fn(A) ::= postfix_expr_no_fn(B).
{
    A = B;
}

unary_expr_no_fn(A) ::= DELETE(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DELETE);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= VOID(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::VOID);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= TYPEOF(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::TYPEOF);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= INCREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INCREMENT);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= DECREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DECREMENT);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= PLUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::PLUS);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= MINUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::MINUS);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= INV(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INV);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= NOT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::NOT);
    A->element(B, C);

    delete B;
}

/* Rule 'mul_expr' */
%type mul_expr { Expression * }

mul_expr(A) ::= unary_expr(B).
{
    A = B;
}

mul_expr(A) ::= mul_expr(B) MUL(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MUL);
    A->element(B, C);

    delete D;
}

mul_expr(A) ::= mul_expr(B) DIV(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::DIV);
    A->element(B, C);

    delete D;
}

mul_expr(A) ::= mul_expr(B) MOD(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MOD);
    A->element(B, C);

    delete D;
}

/* Rule 'mul_expr_no_fn' */
%type mul_expr_no_fn { Expression * }

mul_expr_no_fn(A) ::= unary_expr_no_fn(B).
{
    A = B;
}

mul_expr_no_fn(A) ::= mul_expr_no_fn(B) MUL(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MUL);
    A->element(B, C);

    delete D;
}

mul_expr_no_fn(A) ::= mul_expr_no_fn(B) DIV(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::DIV);
    A->element(B, C);

    delete D;
}

mul_expr_no_fn(A) ::= mul_expr_no_fn(B) MOD(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MOD);
    A->element(B, C);

    delete D;
}

/* Rule 'add_expr' */
%type add_expr { Expression * }

add_expr(A) ::= mul_expr(B).
{
    A = B;
}

add_expr(A) ::= add_expr(B) PLUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::PLUS);
    A->element(B, C);

    delete D;
}

add_expr(A) ::= add_expr(B) MINUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MINUS);
    A->element(B, C);

    delete D;
}

/* Rule 'add_expr_no_fn' */
%type add_expr_no_fn { Expression * }

add_expr_no_fn(A) ::= mul_expr_no_fn(B).
{
    A = B;
}

add_expr_no_fn(A) ::= add_expr_no_fn(B) PLUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::PLUS);
    A->element(B, C);

    delete D;
}

add_expr_no_fn(A) ::= add_expr_no_fn(B) MINUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MINUS);
    A->element(B, C);

    delete D;
}

/* Rule 'shift_expr' */
%type shift_expr { Expression * }

shift_expr(A) ::= add_expr(B).
{
    A = B;
}

shift_expr(A) ::= shift_expr(B) LEFT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LEFT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr(A) ::= shift_expr(B) RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr(A) ::= shift_expr(B) ZERO_RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::ZERO_RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

/* Rule 'shift_expr_no_fn' */
%type shift_expr_no_fn { Expression * }

shift_expr_no_fn(A) ::= add_expr_no_fn(B).
{
    A = B;
}

shift_expr_no_fn(A) ::= shift_expr_no_fn(B) LEFT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LEFT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr_no_fn(A) ::= shift_expr_no_fn(B) RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr_no_fn(A) ::= shift_expr_no_fn(B) ZERO_RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::ZERO_RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

/* Rule 'rel_expr' */
%type rel_expr { Expression * }

rel_expr(A) ::= shift_expr(B).
{
    A = B;
}

rel_expr(A) ::= rel_expr(B) LESSER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) GREATER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) LESSER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) GREATER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) INSTANCEOF(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::INSTANCEOF);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) IN(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::IN);
    A->element(B, C);

    delete D;
}

/* Rule 'rel_expr_no_fn' */
%type rel_expr_no_fn { Expression * }

rel_expr_no_fn(A) ::= shift_expr_no_fn(B).
{
    A = B;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) LESSER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) GREATER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) LESSER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) GREATER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) INSTANCEOF(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::INSTANCEOF);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) IN(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::IN);
    A->element(B, C);

    delete D;
}

/* Rule 'rel_expr_no_in' */
%type rel_expr_no_in { Expression * }

rel_expr_no_in(A) ::= shift_expr(B).
{
    A = B;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) LESSER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) GREATER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) LESSER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) GREATER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) INSTANCEOF(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::INSTANCEOF);
    A->element(B, C);

    delete D;
}

/* Rule 'eq_expr' */
%type eq_expr { Expression * }

eq_expr(A) ::= rel_expr(B).
{
    A = B;
}

eq_expr(A) ::= eq_expr(B) EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr(A) ::= eq_expr(B) NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::NOT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr(A) ::= eq_expr(B) STRICT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr(A) ::= eq_expr(B) STRICT_NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_NOT_EQUAL);
    A->element(B, C);

    delete D;
}

/* Rule 'eq_expr_no_fn' */
%type eq_expr_no_fn { Expression * }

eq_expr_no_fn(A) ::= rel_expr_no_fn(B).
{
    A = B;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::NOT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) STRICT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) STRICT_NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_NOT_EQUAL);
    A->element(B, C);

    delete D;
}

/* Rule 'eq_expr_no_in' */
%type eq_expr_no_in { Expression * }

eq_expr_no_in(A) ::= rel_expr_no_in(B).
{
    A = B;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) NOT_EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::NOT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) STRICT_EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) STRICT_NOT_EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_NOT_EQUAL);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_and_expr' */
%type bit_and_expr { Expression * }

bit_and_expr(A) ::= eq_expr(B).
{
    A = B;
}

bit_and_expr(A) ::= bit_and_expr(B) BITWISE_AND(D) eq_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_and_expr_no_fn' */
%type bit_and_expr_no_fn { Expression * }

bit_and_expr_no_fn(A) ::= eq_expr_no_fn(B).
{
    A = B;
}

bit_and_expr_no_fn(A) ::= bit_and_expr_no_fn(B) BITWISE_AND(D) eq_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_and_expr_no_in' */
%type bit_and_expr_no_in { Expression * }

bit_and_expr_no_in(A) ::= eq_expr_no_in(B).
{
    A = B;
}

bit_and_expr_no_in(A) ::= bit_and_expr_no_in(B) BITWISE_AND(D) eq_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_xor_expr' */
%type bit_xor_expr { Expression * }

bit_xor_expr(A) ::= bit_and_expr(B).
{
    A = B;
}

bit_xor_expr(A) ::= bit_xor_expr(B) BITWISE_XOR(D) bit_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_XOR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_xor_expr_no_fn' */
%type bit_xor_expr_no_fn { Expression * }

bit_xor_expr_no_fn(A) ::= bit_and_expr_no_fn(B).
{
    A = B;
}

bit_xor_expr_no_fn(A) ::= bit_xor_expr_no_fn(B) BITWISE_XOR(D) bit_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_XOR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_xor_expr_no_in' */
%type bit_xor_expr_no_in { Expression * }

bit_xor_expr_no_in(A) ::= bit_and_expr_no_in(B).
{
    A = B;
}

bit_xor_expr_no_in(A) ::= bit_xor_expr_no_in(B) BITWISE_XOR(D) bit_and_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_XOR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_or_expr' */
%type bit_or_expr { Expression * }

bit_or_expr(A) ::= bit_xor_expr(B).
{
    A = B;
}

bit_or_expr(A) ::= bit_or_expr(B) BITWISE_OR(D) bit_xor_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_or_expr_no_fn' */
%type bit_or_expr_no_fn { Expression * }

bit_or_expr_no_fn(A) ::= bit_xor_expr_no_fn(B).
{
    A = B;
}

bit_or_expr_no_fn(A) ::= bit_or_expr_no_fn(B) BITWISE_OR(D) bit_xor_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_or_expr_no_in' */
%type bit_or_expr_no_in { Expression * }

bit_or_expr_no_in(A) ::= bit_xor_expr_no_in(B).
{
    A = B;
}

bit_or_expr_no_in(A) ::= bit_or_expr_no_in(B) BITWISE_OR(D) bit_xor_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_and_expr' */
%type logic_and_expr { Expression * }

logic_and_expr(A) ::= bit_or_expr(B).
{
    A = B;
}

logic_and_expr(A) ::= logic_and_expr(B) LOGIC_AND(D) bit_or_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_and_expr_no_fn' */
%type logic_and_expr_no_fn { Expression * }

logic_and_expr_no_fn(A) ::= bit_or_expr_no_fn(B).
{
    A = B;
}

logic_and_expr_no_fn(A) ::= logic_and_expr_no_fn(B) LOGIC_AND(D) bit_or_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_and_expr_no_in' */
%type logic_and_expr_no_in { Expression * }

logic_and_expr_no_in(A) ::= bit_or_expr_no_in(B).
{
    A = B;
}

logic_and_expr_no_in(A) ::= logic_and_expr_no_in(B) LOGIC_AND(D) bit_or_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_or_expr' */
%type logic_or_expr { Expression * }

logic_or_expr(A) ::= logic_and_expr(B).
{
    A = B;
}

logic_or_expr(A) ::= logic_or_expr(B) LOGIC_OR(D) logic_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_or_expr_no_fn' */
%type logic_or_expr_no_fn { Expression * }

logic_or_expr_no_fn(A) ::= logic_and_expr_no_fn(B).
{
    A = B;
}

logic_or_expr_no_fn(A) ::= logic_or_expr_no_fn(B) LOGIC_OR(D) logic_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_or_expr_no_in' */
%type logic_or_expr_no_in { Expression * }

logic_or_expr_no_in(A) ::= logic_and_expr_no_in(B).
{
    A = B;
}

logic_or_expr_no_in(A) ::= logic_or_expr_no_in(B) LOGIC_OR(D) logic_and_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'cond_expr' */
%type cond_expr { Expression * }

cond_expr(A) ::= logic_or_expr(B).
{
    A = B;
}

cond_expr(A) ::= logic_or_expr(B) QUESTION(E) assign_expr(C) COLON(F) assign_expr(D).
{
    A = new expr::Condition(B, C, D);
    A->element(B, D);

    delete E;
    delete F;
}

/* Rule 'cond_expr_no_fn' */
%type cond_expr_no_fn { Expression * }

cond_expr_no_fn(A) ::= logic_or_expr_no_fn(B).
{
    A = B;
}

cond_expr_no_fn(A) ::= logic_or_expr_no_fn(B) QUESTION(E) assign_expr(C) COLON(F) assign_expr(D).
{
    A = new expr::Condition(B, C, D);
    A->element(B, D);

    delete E;
    delete F;
}

/* Rule 'cond_expr_no_in' */
%type cond_expr_no_in { Expression * }

cond_expr_no_in(A) ::= logic_or_expr_no_in(B).
{
    A = B;
}

cond_expr_no_in(A) ::= logic_or_expr_no_in(B) QUESTION(E) assign_expr(C) COLON(F) assign_expr_no_in(D).
{
    A = new expr::Condition(B, C, D);
    A->element(B, D);

    delete E;
    delete F;
}

/* Rule 'assign_expr' */
%type assign_expr { Expression * }

assign_expr(A) ::= cond_expr(B).
{
    A = B;
}

assign_expr(A) ::= left_hand_expr(B) assign_op(C) assign_expr(D).
{
    A = new expr::Assign(B, D, C);
    A->element(B, D);
}

/* Rule 'assign_expr_no_fn' */
%type assign_expr_no_fn { Expression * }

assign_expr_no_fn(A) ::= cond_expr_no_fn(B).
{
    A = B;
}

assign_expr_no_fn(A) ::= left_hand_expr_no_fn(B) assign_op(C) assign_expr(D).
{
    A = new expr::Assign(B, D, C);
    A->element(B, D);
}

/* Rule 'assign_expr_no_in' */
%type assign_expr_no_in { Expression * }

assign_expr_no_in(A) ::= cond_expr_no_in(B).
{
    A = B;
}

assign_expr_no_in(A) ::= left_hand_expr(B) assign_op(C) assign_expr_no_in(D).
{
    A = new expr::Assign(B, D, C);
    A->element(B, D);
}

/* Rule 'assign_op' */
%type assign_op { expr::Assign::OpType }

assign_op(A) ::= ASSIGN(B).
{
    A = expr::Assign::OpType::SIMPLE;

    delete B;
}

assign_op(A) ::= MUL_ASSIGN(B).
{
    A = expr::Assign::OpType::MUL;

    delete B;
}

assign_op(A) ::= DIV_ASSIGN(B).
{
    A = expr::Assign::OpType::DIV;

    delete B;
}

assign_op(A) ::= MOD_ASSIGN(B).
{
    A = expr::Assign::OpType::MOD;

    delete B;
}

assign_op(A) ::= PLUS_ASSIGN(B).
{
    A = expr::Assign::OpType::PLUS;

    delete B;
}

assign_op(A) ::= MINUS_ASSIGN(B).
{
    A = expr::Assign::OpType::MINUS;

    delete B;
}

assign_op(A) ::= LEFT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::LEFT_SHIFT;

    delete B;
}

assign_op(A) ::= RIGHT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::RIGHT_SHIFT;

    delete B;
}

assign_op(A) ::= ZERO_RIGHT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::ZERO_RIGHT_SHIFT;

    delete B;
}

assign_op(A) ::= BITWISE_AND_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_AND;

    delete B;
}

assign_op(A) ::= BITWISE_XOR_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_XOR;

    delete B;
}

assign_op(A) ::= BITWISE_OR_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_OR;

    delete B;
}

/* Rule 'expr' */
%type expr { expr::Expressions * }

expr(A) ::= assign_expr(B).
{
    A = new expr::Expressions();
    A->items().push_back(std::unique_ptr<Expression>(B));
}

expr(A) ::= expr(B) COMMA(D) assign_expr(C).
{
    A = B;
    A->items().push_back(std::unique_ptr<Expression>(C));

    delete D;
}

/* Rule 'expr_no_fn' */
%type expr_no_fn { expr::Expressions * }

expr_no_fn(A) ::= assign_expr_no_fn(B).
{
    A = new expr::Expressions();
    A->items().push_back(std::unique_ptr<Expression>(B));
}

expr_no_fn(A) ::= expr_no_fn(B) COMMA(D) assign_expr(C).
{
    A = B;
    A->items().push_back(std::unique_ptr<Expression>(C));

    delete D;
}

/* Rule 'expr_no_in' */
%type expr_no_in { expr::Expressions * }

expr_no_in(A) ::= assign_expr_no_in(B).
{
    A = new expr::Expressions();
    A->items().push_back(std::unique_ptr<Expression>(B));
}

expr_no_in(A) ::= expr_no_in(B) COMMA(D) assign_expr_no_in(C).
{
    A = B;
    A->items().push_back(std::unique_ptr<Expression>(C));

    delete D;
}

/* Rule 'literal' */
%type literal { Expression * }

literal(A) ::= LIT_NULL(B).
{
    A = new expr::literal::Null();
    A->element(B);

    delete B;
}

literal(A) ::= LIT_TRUE(B).
{
    A = new expr::literal::Boolean(true);
    A->element(B);

    delete B;
}

literal(A) ::= LIT_FALSE(B).
{
    A = new expr::literal::Boolean(false);
    A->element(B);

    delete B;
}

literal(A) ::= NUMBER(B).
{
    A = new expr::literal::Number(B->text());
    A->element(B);

    delete B;
}

literal(A) ::= STRING(B).
{
    const std::string content = B->text().substr(1, B->text().length() - 2);

    A = new expr::literal::String(content);
    A->element(B);

    delete B;
}

literal(A) ::= REGEXP(B).
{
    A = new expr::literal::Regexp(B->text());
    A->element(B);

    delete B;
}

/* Rule 'array' */
%type array { expr::Array * }

array(A) ::= LBRACKET(B) RBRACKET(C).
{
    A = new expr::Array();

    delete B;
    delete C;
}

array(A) ::= LBRACKET(C) array_elision(B) RBRACKET(D).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete C;
    delete B;
    delete D;
}

array(A) ::= LBRACKET(C) array_element_list(B) RBRACKET(D).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete C;
    delete B;
    delete D;
}

array(A) ::= LBRACKET(C) array_element_list(B) COMMA(D) RBRACKET(E).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete C;
    delete B;
    delete D;
    delete E;
}

array(A) ::= LBRACKET(D) array_element_list(B) COMMA(E) array_elision(C) RBRACKET(F).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete D;
    delete B;
    delete E;
    delete C;
    delete F;
}

/* Rule 'array_elision' */
%type array_elision { std::vector<std::unique_ptr<Expression>> * }

array_elision(A) ::= COMMA(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(nullptr);

    delete B;
}

array_elision(A) ::= array_elision(B) COMMA(C).
{
    A = B;
    A->push_back(nullptr);

    delete C;
}

/* Rule 'array_element_list' */
%type array_element_list { std::vector<std::unique_ptr<Expression>> * }

array_element_list(A) ::= assign_expr(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(std::unique_ptr<Expression>(B));
}

array_element_list(A) ::= array_elision(B) assign_expr(C).
{
    A = B;
    A->push_back(std::unique_ptr<Expression>(C));
}

array_element_list(A) ::= array_element_list(B) COMMA(D) assign_expr(C).
{
    A = B;
    A->push_back(std::unique_ptr<Expression>(C));

    delete D;
}

array_element_list(A) ::= array_element_list(B) COMMA(E) array_elision(C) assign_expr(D).
{
    A = B;

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->push_back(std::move(*it));
    }

    A->push_back(std::unique_ptr<Expression>(D));

    delete E;
    delete C;
}

/* Rule 'object' */
%type object { expr::Object * }

object(A) ::= LBRACE(B) RBRACE(C).
{
    A = new expr::Object();

    delete B;
    delete C;
}

object(A) ::= LBRACE(B) object_properties(C) RBRACE(D).
{
    A = new expr::Object();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->properties().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

object(A) ::= LBRACE(B) object_properties(C) COMMA(E) RBRACE(D).
{
    A = new expr::Object();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->properties().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete C;
    delete E;
    delete D;
}

/* Rule 'object_properties' */
%type object_properties { std::vector<std::unique_ptr<expr::object::Property>> * }

object_properties(A) ::= object_property(B).
{
    A = new std::vector<std::unique_ptr<expr::object::Property>>();
    A->push_back(std::unique_ptr<expr::object::Property>(B));
}

object_properties(A) ::= object_properties(B) COMMA(D) object_property(C).
{
    A = B;
    A->push_back(std::unique_ptr<expr::object::Property>(C));

    delete D;
}

/* Rule 'object_property' */
%type object_property { expr::object::Property * }

object_property(A) ::= object_property_name(B) COLON(D) assign_expr(C).
{
    A = new expr::object::Property();
    A->key(B);
    A->value(C);
    A->element(B, C);

    delete D;
}

object_property ::= GET(A) object_property_name LPAREN(B) RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

object_property ::= SET(A) object_property_name LPAREN(B) object_property_set_params RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

/* Rule 'object_property_name' */
%type object_property_name { Expression * }

object_property_name(A) ::= ident(B).
{
    A = B;
}

object_property_name(A) ::= STRING(B).
{
    A = new expr::literal::String(B->text());
    A->element(B);

    delete B;
}

object_property_name(A) ::= NUMBER(B).
{
    A = new expr::literal::Number(B->text());
    A->element(B);

    delete B;
}

/* Rule 'object_property_set_params' */
%type object_property_set_params { std::vector<std::string> * }

object_property_set_params(A) ::= ident(B).
{
    A = new std::vector<std::string>();
    A->push_back(B->name());

    delete B;
}

/* Rule 'arguments' */
%type arguments { args::Arguments * }

arguments(A) ::= LPAREN(B) RPAREN(C).
{
    A = new args::Arguments();
    A->element(B, C);

    delete B;
    delete C;
}

arguments(A) ::= LPAREN(B) arguments_list(C) RPAREN(D).
{
    A = new args::Arguments();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'arguments_list' */
%type arguments_list { std::vector<std::unique_ptr<Expression>> * }

arguments_list(A) ::= assign_expr(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(std::unique_ptr<Expression>(B));
}

arguments_list(A) ::= arguments_list(B) COMMA(D) assign_expr(C).
{
    A = B;
    A->push_back(std::unique_ptr<Expression>(C));

    delete D;
}

%token_prefix       ECMA_TOKEN_TYPE_
%token_type         { lex::Token * }
%extra_argument     { parser::Parser *parser }
%name               ecma_parse

%include
{
    #include <cassert>
    #include <cstdio>
    #include <memory>
    #include <vector>
    #include <string>
    #include "ecma/lex/token.h"
    #include "ecma/parser/parser.h"
    #include "ecma/parser/exception.h"

    #include "ecma/ast/ast.h"

    using namespace ecma;
}

%syntax_error {
    std::vector<std::string> expected;

    int n = sizeof(yyTokenName) / sizeof(*yyTokenName);
    for (int i = 0; i < n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            expected.push_back(yyTokenName[i]);
        }
    }
    throw parser::UnexpectedToken(*TOKEN, expected);
}

%left INSTANCEOF CONTINUE DEBUGGER FUNCTION DEFAULT FINALLY DELETE RETURN SWITCH TYPEOF BREAK CATCH THROW WHILE CASE ELSE THIS VOID WITH FOR NEW TRY VAR DO IF IN.
%left EXTENDS EXPORT IMPORT CLASS CONST SUPER ENUM.
%left IMPLEMENTS INTERFACE PROTECTED PACKAGE PRIVATE PUBLIC STATIC YIELD LET.
%left ZERO_RIGHT_SHIFT_ASSIGN STRICT_EQUAL STRICT_NOT_EQUAL ZERO_RIGHT_SHIFT LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN LESSER_EQ GREATER_EQ EQUAL NOT_EQUAL INCREMENT DECREMENT LEFT_SHIFT RIGHT_SHIFT LOGIC_AND LOGIC_OR PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET DOT SEMICOLON COMMA QUESTION COLON LESSER GREATER PLUS MINUS MUL MOD DIV BITWISE_AND BITWISE_OR BITWISE_XOR ASSIGN NOT INV.
%left LIT_UNDEFINED NUMBER STRING REGEXP LIT_FALSE IDENT LIT_NULL LIT_TRUE.

/* Rule 'module' */
%start_symbol module

module ::= primary_expr.
{}

/* Rule 'primary_expr' */

primary_expr ::= THIS.
{}

primary_expr ::= IDENT.
{}

primary_expr ::= literal.
{}

primary_expr ::= array.
{}

/* Rule 'assign_expr' */

assign_expr ::= primary_expr.
{}

/* Rule 'literal' */

literal ::= LIT_NULL.
{}

literal ::= LIT_TRUE.
{}

literal ::= LIT_FALSE.
{}

literal ::= NUMBER.
{}

literal ::= STRING.
{}

literal ::= REGEXP.
{}

/* Rule 'array' */

array ::= LBRACKET RBRACKET.
{}

array ::= LBRACKET array_elision RBRACKET.
{}

array ::= LBRACKET array_element_list RBRACKET.
{}

array ::= LBRACKET array_element_list COMMA RBRACKET.
{}

array ::= LBRACKET array_element_list COMMA array_elision RBRACKET.
{}

/* Rule 'array_elision' */

array_elision ::= COMMA.
{}

array_elision ::= array_elision COMMA.
{}

/* Rule 'array_element_list' */

array_element_list ::= assign_expr.
{}

array_element_list ::= array_elision assign_expr.
{}

array_element_list ::= array_element_list COMMA assign_expr.
{}

array_element_list ::= array_element_list COMMA array_elision assign_expr.
{}

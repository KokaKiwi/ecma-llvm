%token_prefix       ECMA_TOKEN_TYPE_
%token_type         { lex::Token * }
%extra_argument     { parser::Parser *parser }
%name               ecma_parse

%include
{
    #include <cassert>
    #include <cstdio>
    #include <memory>
    #include <vector>
    #include <string>
    #include "ecma/lex/token.h"
    #include "ecma/parser/parser.h"
    #include "ecma/parser/exception.h"

    #include "ecma/ast/ast.h"

    using namespace ecma;
}

%syntax_error {
    std::vector<std::string> expected;

    int n = sizeof(yyTokenName) / sizeof(*yyTokenName);
    for (int i = 0; i < n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            expected.push_back(yyTokenName[i]);
        }
    }
    throw parser::UnexpectedToken(*TOKEN, expected);
}

%left INSTANCEOF CONTINUE DEBUGGER FUNCTION DEFAULT FINALLY DELETE RETURN SWITCH TYPEOF BREAK CATCH THROW WHILE CASE THIS VOID WITH FOR GET NEW SET TRY VAR DO IN.
%right ELSE IF.
%left EXTENDS EXPORT IMPORT CLASS CONST SUPER ENUM.
%left IMPLEMENTS INTERFACE PROTECTED PACKAGE PRIVATE PUBLIC STATIC YIELD LET.
%left ZERO_RIGHT_SHIFT_ASSIGN STRICT_EQUAL STRICT_NOT_EQUAL ZERO_RIGHT_SHIFT LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN LESSER_EQ GREATER_EQ EQUAL NOT_EQUAL INCREMENT DECREMENT LEFT_SHIFT RIGHT_SHIFT LOGIC_AND LOGIC_OR PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET DOT SEMICOLON COMMA QUESTION COLON LESSER GREATER PLUS MINUS MUL MOD DIV BITWISE_AND BITWISE_OR BITWISE_XOR ASSIGN NOT INV.
%left LIT_UNDEFINED NUMBER STRING REGEXP LIT_FALSE IDENT LIT_NULL LIT_TRUE.

/* Rule 'module' */
%start_symbol module

module ::= .
{}

module ::= source_elements.
{}

/* Rule 'ident_name' */

ident_name ::= IDENT.
{}

/* Rule 'function_decl' */

function_decl ::= FUNCTION IDENT LPAREN RPAREN LBRACE function_body RBRACE.
{}

function_decl ::= FUNCTION IDENT LPAREN formal_params RPAREN LBRACE function_body RBRACE.
{}

/* Rule 'function_expr' */

function_expr ::= FUNCTION IDENT LPAREN RPAREN LBRACE function_body RBRACE.
{}

function_expr ::= FUNCTION IDENT LPAREN formal_params RPAREN LBRACE function_body RBRACE.
{}

function_expr ::= FUNCTION LPAREN RPAREN LBRACE function_body RBRACE.
{}

function_expr ::= FUNCTION LPAREN formal_params RPAREN LBRACE function_body RBRACE.
{}

/* Rule 'formal_params' */

formal_params ::= IDENT.
{}

formal_params ::= formal_params COMMA IDENT.
{}

/* Rule 'function_body' */

function_body ::= .
{}

function_body ::= source_elements.
{}

/* Rule 'source_elements' */

source_elements ::= source_element.
{}

source_elements ::= source_elements source_element.
{}

/* Rule 'source_element' */

source_element ::= stmt.
{}

source_element ::= function_decl.
{}

/* Rule 'stmt' */

stmt ::= block.
{}

stmt ::= var_stmt.
{}

stmt ::= empty_stmt.
{}

stmt ::= expr_stmt.
{}

stmt ::= if_stmt.
{}

stmt ::= iter_stmt.
{}

stmt ::= cont_stmt.
{}

stmt ::= break_stmt.
{}

stmt ::= return_stmt.
{}

stmt ::= with_stmt.
{}

stmt ::= switch_stmt.
{}

stmt ::= label_stmt.
{}

stmt ::= throw_stmt.
{}

stmt ::= try_stmt.
{}

stmt ::= debug_stmt.
{}

/* Rule 'block' */

block ::= LBRACE stmt_list RBRACE.
{}

/* Rule 'block_empty' */

block_empty ::= LBRACE RBRACE.
{}

/* Rule 'block_stmt' */

block_stmt ::= block.
{}

block_stmt ::= block_empty.
{}

/* Rule 'stmt_list' */

stmt_list ::= stmt.
{}

stmt_list ::= stmt_list stmt.
{}

/* Rule 'var_stmt' */

var_stmt ::= VAR var_decls SEMICOLON.
{}

/* Rule 'var_decls' */

var_decls ::= var_decl.
{}

var_decls ::= var_decls COMMA var_decl.
{}

/* Rule 'var_decls_no_in' */

var_decls_no_in ::= var_decl_no_in.
{}

var_decls_no_in ::= var_decls_no_in COMMA var_decl_no_in.
{}

/* Rule 'var_decl' */

var_decl ::= IDENT.
{}

var_decl ::= IDENT init.
{}

/* Rule 'var_decl_no_in' */

var_decl_no_in ::= IDENT.
{}

var_decl_no_in ::= IDENT init_no_in.
{}

/* Rule 'init' */

init ::= ASSIGN assign_expr.
{}

/* Rule 'init_no_in' */

init_no_in ::= ASSIGN assign_expr_no_in.
{}

/* Rule 'empty_stmt' */

empty_stmt ::= SEMICOLON.
{}

/* Rule 'expr_stmt' */

expr_stmt ::= expr_no_fn SEMICOLON.
{}

/* Rule 'if_stmt' */

if_stmt ::= IF LPAREN expr RPAREN stmt.
{}

if_stmt ::= IF LPAREN expr RPAREN stmt ELSE stmt.
{}

/* Rule 'iter_stmt' */

iter_stmt ::= DO stmt WHILE LPAREN expr RPAREN.
{}

iter_stmt ::= WHILE LPAREN expr RPAREN stmt.
{}

iter_stmt ::= FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_loop RPAREN stmt.
{}

iter_stmt ::= FOR LPAREN VAR var_decls_no_in SEMICOLON for_cond SEMICOLON for_loop RPAREN stmt.
{}

iter_stmt ::= FOR LPAREN left_hand_expr IN expr RPAREN stmt.
{}

iter_stmt ::= FOR LPAREN VAR var_decl_no_in IN expr RPAREN stmt.
{}

/* Rule 'for_init' */

for_init ::= .
{}

for_init ::= expr_no_in.
{}

/* Rule 'for_cond' */

for_cond ::= .
{}

for_cond ::= expr.
{}

/* Rule 'for_loop' */

for_loop ::= .
{}

for_loop ::= expr.
{}

/* Rule 'cont_stmt' */

cont_stmt ::= CONTINUE SEMICOLON.
{}

cont_stmt ::= CONTINUE IDENT SEMICOLON.
{}

/* Rule 'break_stmt' */

break_stmt ::= BREAK SEMICOLON.
{}

break_stmt ::= BREAK IDENT SEMICOLON.
{}

/* Rule 'return_stmt' */

return_stmt ::= RETURN SEMICOLON.
{}

return_stmt ::= RETURN expr SEMICOLON.
{}

/* Rule 'with_stmt' */

with_stmt ::= WITH LPAREN expr RPAREN stmt.
{}

/* Rule 'switch_stmt' */

switch_stmt ::= SWITCH LPAREN expr RPAREN case_block.
{}

/* Rule 'case_block' */

case_block ::= LBRACE RBRACE.
{}

case_block ::= LBRACE case_clauses RBRACE.
{}

/* Rule 'case_clauses' */

case_clauses ::= case_clause.
{}

case_clauses ::= case_clauses case_clause.
{}

/* Rule 'case_clause' */

case_clause ::= case_key COLON.
{}

case_clause ::= case_key COLON stmt_list.
{}

/* Rule 'case_key' */

case_key ::= CASE expr.
{}

case_key ::= DEFAULT.
{}

/* Rule 'label_stmt' */

label_stmt ::= IDENT COLON stmt.
{}

/* Rule 'throw_stmt' */

throw_stmt ::= THROW expr SEMICOLON.
{}

/* Rule 'try_stmt' */

try_stmt ::= TRY block_stmt catch.
{}

try_stmt ::= TRY block_stmt finally.
{}

try_stmt ::= TRY block_stmt catch finally.
{}

/* Rule 'catch' */

catch ::= CATCH LPAREN IDENT RPAREN block_stmt.
{}

/* Rule 'finally' */

finally ::= FINALLY block_stmt.
{}

/* Rule 'debug_stmt' */

debug_stmt ::= DEBUGGER SEMICOLON.
{}

/* Rule 'primary_expr' */

primary_expr ::= THIS.
{}

primary_expr ::= IDENT.
{}

primary_expr ::= literal.
{}

primary_expr ::= array.
{}

primary_expr ::= object.
{}

primary_expr ::= LPAREN expr RPAREN.
{}

/* Rule 'member_expr' */

member_expr ::= primary_expr.
{}

member_expr ::= function_expr.
{}

member_expr ::= member_expr LBRACKET expr RBRACKET.
{}

member_expr ::= member_expr DOT ident_name.
{}

member_expr ::= NEW member_expr arguments.
{}

/* Rule 'member_expr_no_fn' */

member_expr_no_fn ::= primary_expr.
{}

member_expr_no_fn ::= member_expr_no_fn LBRACKET expr RBRACKET.
{}

member_expr_no_fn ::= member_expr_no_fn DOT ident_name.
{}

member_expr_no_fn ::= NEW member_expr arguments.
{}

/* Rule 'new_expr' */

new_expr ::= member_expr.
{}

new_expr ::= NEW new_expr.
{}

/* Rule 'new_expr_no_fn' */

new_expr_no_fn ::= member_expr_no_fn.
{}

new_expr_no_fn ::= NEW new_expr.
{}

/* Rule 'call_expr' */

call_expr ::= member_expr arguments.
{}

call_expr ::= call_expr arguments.
{}

call_expr ::= call_expr LBRACKET expr RBRACKET.
{}

call_expr ::= call_expr DOT ident_name.
{}

/* Rule 'call_expr_no_fn' */

call_expr_no_fn ::= member_expr_no_fn arguments.
{}

call_expr_no_fn ::= call_expr_no_fn arguments.
{}

call_expr_no_fn ::= call_expr_no_fn LBRACKET expr RBRACKET.
{}

call_expr_no_fn ::= call_expr_no_fn DOT ident_name.
{}

/* Rule 'left_hand_expr' */

left_hand_expr ::= new_expr.
{}

left_hand_expr ::= call_expr.
{}

/* Rule 'left_hand_expr_no_fn' */

left_hand_expr_no_fn ::= new_expr_no_fn.
{}

left_hand_expr_no_fn ::= call_expr_no_fn.
{}

/* Rule 'postfix_expr' */

postfix_expr ::= left_hand_expr.
{}

postfix_expr ::= left_hand_expr INCREMENT.
{}

postfix_expr ::= left_hand_expr DECREMENT.
{}

/* Rule 'postfix_expr_no_fn' */

postfix_expr_no_fn ::= left_hand_expr_no_fn.
{}

postfix_expr_no_fn ::= left_hand_expr_no_fn INCREMENT.
{}

postfix_expr_no_fn ::= left_hand_expr_no_fn DECREMENT.
{}

/* Rule 'unary_expr' */

unary_expr ::= postfix_expr.
{}

unary_expr ::= DELETE unary_expr.
{}

unary_expr ::= VOID unary_expr.
{}

unary_expr ::= TYPEOF unary_expr.
{}

unary_expr ::= INCREMENT unary_expr.
{}

unary_expr ::= DECREMENT unary_expr.
{}

unary_expr ::= PLUS unary_expr.
{}

unary_expr ::= MINUS unary_expr.
{}

unary_expr ::= INV unary_expr.
{}

unary_expr ::= NOT unary_expr.
{}

/* Rule 'unary_expr_no_fn' */

unary_expr_no_fn ::= postfix_expr_no_fn.
{}

unary_expr_no_fn ::= DELETE unary_expr.
{}

unary_expr_no_fn ::= VOID unary_expr.
{}

unary_expr_no_fn ::= TYPEOF unary_expr.
{}

unary_expr_no_fn ::= INCREMENT unary_expr.
{}

unary_expr_no_fn ::= DECREMENT unary_expr.
{}

unary_expr_no_fn ::= PLUS unary_expr.
{}

unary_expr_no_fn ::= MINUS unary_expr.
{}

unary_expr_no_fn ::= INV unary_expr.
{}

unary_expr_no_fn ::= NOT unary_expr.
{}

/* Rule 'mul_expr' */

mul_expr ::= unary_expr.
{}

mul_expr ::= mul_expr MUL unary_expr.
{}

mul_expr ::= mul_expr DIV unary_expr.
{}

mul_expr ::= mul_expr MOD unary_expr.
{}

/* Rule 'mul_expr_no_fn' */

mul_expr_no_fn ::= unary_expr_no_fn.
{}

mul_expr_no_fn ::= mul_expr_no_fn MUL unary_expr.
{}

mul_expr_no_fn ::= mul_expr_no_fn DIV unary_expr.
{}

mul_expr_no_fn ::= mul_expr_no_fn MOD unary_expr.
{}

/* Rule 'add_expr' */

add_expr ::= mul_expr.
{}

add_expr ::= add_expr PLUS mul_expr.
{}

add_expr ::= add_expr MINUS mul_expr.
{}

/* Rule 'add_expr_no_fn' */

add_expr_no_fn ::= mul_expr_no_fn.
{}

add_expr_no_fn ::= add_expr_no_fn PLUS mul_expr.
{}

add_expr_no_fn ::= add_expr_no_fn MINUS mul_expr.
{}

/* Rule 'shift_expr' */

shift_expr ::= add_expr.
{}

shift_expr ::= shift_expr LEFT_SHIFT add_expr.
{}

shift_expr ::= shift_expr RIGHT_SHIFT add_expr.
{}

shift_expr ::= shift_expr ZERO_RIGHT_SHIFT add_expr.
{}

/* Rule 'shift_expr_no_fn' */

shift_expr_no_fn ::= add_expr_no_fn.
{}

shift_expr_no_fn ::= shift_expr_no_fn LEFT_SHIFT add_expr.
{}

shift_expr_no_fn ::= shift_expr_no_fn RIGHT_SHIFT add_expr.
{}

shift_expr_no_fn ::= shift_expr_no_fn ZERO_RIGHT_SHIFT add_expr.
{}

/* Rule 'rel_expr' */

rel_expr ::= shift_expr.
{}

rel_expr ::= rel_expr LESSER shift_expr.
{}

rel_expr ::= rel_expr GREATER shift_expr.
{}

rel_expr ::= rel_expr LESSER_EQ shift_expr.
{}

rel_expr ::= rel_expr GREATER_EQ shift_expr.
{}

rel_expr ::= rel_expr INSTANCEOF shift_expr.
{}

rel_expr ::= rel_expr IN shift_expr.
{}

/* Rule 'rel_expr_no_fn' */

rel_expr_no_fn ::= shift_expr_no_fn.
{}

rel_expr_no_fn ::= rel_expr_no_fn LESSER shift_expr.
{}

rel_expr_no_fn ::= rel_expr_no_fn GREATER shift_expr.
{}

rel_expr_no_fn ::= rel_expr_no_fn LESSER_EQ shift_expr.
{}

rel_expr_no_fn ::= rel_expr_no_fn GREATER_EQ shift_expr.
{}

rel_expr_no_fn ::= rel_expr_no_fn INSTANCEOF shift_expr.
{}

rel_expr_no_fn ::= rel_expr_no_fn IN shift_expr.
{}

/* Rule 'rel_expr_no_in' */

rel_expr_no_in ::= shift_expr.
{}

rel_expr_no_in ::= rel_expr_no_in LESSER shift_expr.
{}

rel_expr_no_in ::= rel_expr_no_in GREATER shift_expr.
{}

rel_expr_no_in ::= rel_expr_no_in LESSER_EQ shift_expr.
{}

rel_expr_no_in ::= rel_expr_no_in GREATER_EQ shift_expr.
{}

rel_expr_no_in ::= rel_expr_no_in INSTANCEOF shift_expr.
{}

/* Rule 'eq_expr' */

eq_expr ::= rel_expr.
{}

eq_expr ::= eq_expr EQUAL rel_expr.
{}

eq_expr ::= eq_expr NOT_EQUAL rel_expr.
{}

eq_expr ::= eq_expr STRICT_EQUAL rel_expr.
{}

eq_expr ::= eq_expr STRICT_NOT_EQUAL rel_expr.
{}

/* Rule 'eq_expr_no_fn' */

eq_expr_no_fn ::= rel_expr_no_fn.
{}

eq_expr_no_fn ::= eq_expr_no_fn EQUAL rel_expr.
{}

eq_expr_no_fn ::= eq_expr_no_fn NOT_EQUAL rel_expr.
{}

eq_expr_no_fn ::= eq_expr_no_fn STRICT_EQUAL rel_expr.
{}

eq_expr_no_fn ::= eq_expr_no_fn STRICT_NOT_EQUAL rel_expr.
{}

/* Rule 'eq_expr_no_in' */

eq_expr_no_in ::= rel_expr_no_in.
{}

eq_expr_no_in ::= eq_expr_no_in EQUAL rel_expr_no_in.
{}

eq_expr_no_in ::= eq_expr_no_in NOT_EQUAL rel_expr_no_in.
{}

eq_expr_no_in ::= eq_expr_no_in STRICT_EQUAL rel_expr_no_in.
{}

eq_expr_no_in ::= eq_expr_no_in STRICT_NOT_EQUAL rel_expr_no_in.
{}

/* Rule 'bit_and_expr' */

bit_and_expr ::= eq_expr.
{}

bit_and_expr ::= bit_and_expr BITWISE_AND eq_expr.
{}

/* Rule 'bit_and_expr_no_fn' */

bit_and_expr_no_fn ::= eq_expr_no_fn.
{}

bit_and_expr_no_fn ::= bit_and_expr_no_fn BITWISE_AND eq_expr.
{}

/* Rule 'bit_and_expr_no_in' */

bit_and_expr_no_in ::= eq_expr_no_in.
{}

bit_and_expr_no_in ::= bit_and_expr_no_in BITWISE_AND eq_expr_no_in.
{}

/* Rule 'bit_xor_expr' */

bit_xor_expr ::= bit_and_expr.
{}

bit_xor_expr ::= bit_xor_expr BITWISE_XOR bit_and_expr.
{}

/* Rule 'bit_xor_expr_no_fn' */

bit_xor_expr_no_fn ::= bit_and_expr_no_fn.
{}

bit_xor_expr_no_fn ::= bit_xor_expr_no_fn BITWISE_XOR bit_and_expr.
{}

/* Rule 'bit_xor_expr_no_in' */

bit_xor_expr_no_in ::= bit_and_expr_no_in.
{}

bit_xor_expr_no_in ::= bit_xor_expr_no_in BITWISE_XOR bit_and_expr_no_in.
{}

/* Rule 'bit_or_expr' */

bit_or_expr ::= bit_xor_expr.
{}

bit_or_expr ::= bit_or_expr BITWISE_OR bit_xor_expr.
{}

/* Rule 'bit_or_expr_no_fn' */

bit_or_expr_no_fn ::= bit_xor_expr_no_fn.
{}

bit_or_expr_no_fn ::= bit_or_expr_no_fn BITWISE_OR bit_xor_expr.
{}

/* Rule 'bit_or_expr_no_in' */

bit_or_expr_no_in ::= bit_xor_expr_no_in.
{}

bit_or_expr_no_in ::= bit_or_expr_no_in BITWISE_OR bit_xor_expr_no_in.
{}

/* Rule 'logic_and_expr' */

logic_and_expr ::= bit_or_expr.
{}

logic_and_expr ::= logic_and_expr LOGIC_AND bit_or_expr.
{}

/* Rule 'logic_and_expr_no_fn' */

logic_and_expr_no_fn ::= bit_or_expr_no_fn.
{}

logic_and_expr_no_fn ::= logic_and_expr_no_fn LOGIC_AND bit_or_expr.
{}

/* Rule 'logic_and_expr_no_in' */

logic_and_expr_no_in ::= bit_or_expr_no_in.
{}

logic_and_expr_no_in ::= logic_and_expr_no_in LOGIC_AND bit_or_expr_no_in.
{}

/* Rule 'logic_or_expr' */

logic_or_expr ::= logic_and_expr.
{}

logic_or_expr ::= logic_or_expr LOGIC_OR logic_and_expr.
{}

/* Rule 'logic_or_expr_no_fn' */

logic_or_expr_no_fn ::= logic_and_expr_no_fn.
{}

logic_or_expr_no_fn ::= logic_or_expr_no_fn LOGIC_OR logic_and_expr.
{}

/* Rule 'logic_or_expr_no_in' */

logic_or_expr_no_in ::= logic_and_expr_no_in.
{}

logic_or_expr_no_in ::= logic_or_expr_no_in LOGIC_OR logic_and_expr_no_in.
{}

/* Rule 'cond_expr' */

cond_expr ::= logic_or_expr.
{}

cond_expr ::= logic_or_expr QUESTION assign_expr COLON assign_expr.
{}

/* Rule 'cond_expr_no_fn' */

cond_expr_no_fn ::= logic_or_expr_no_fn.
{}

cond_expr_no_fn ::= logic_or_expr_no_fn QUESTION assign_expr COLON assign_expr.
{}

/* Rule 'cond_expr_no_in' */

cond_expr_no_in ::= logic_or_expr_no_in.
{}

cond_expr_no_in ::= logic_or_expr_no_in QUESTION assign_expr COLON assign_expr_no_in.
{}

/* Rule 'assign_expr' */

assign_expr ::= cond_expr.
{}

assign_expr ::= left_hand_expr assign_op assign_expr.
{}

/* Rule 'assign_expr_no_fn' */

assign_expr_no_fn ::= cond_expr_no_fn.
{}

assign_expr_no_fn ::= left_hand_expr_no_fn assign_op assign_expr.
{}

/* Rule 'assign_expr_no_in' */

assign_expr_no_in ::= cond_expr_no_in.
{}

assign_expr_no_in ::= left_hand_expr assign_op assign_expr_no_in.
{}

/* Rule 'assign_op' */

assign_op ::= ASSIGN.
{}

assign_op ::= MUL_ASSIGN.
{}

assign_op ::= DIV_ASSIGN.
{}

assign_op ::= MOD_ASSIGN.
{}

assign_op ::= PLUS_ASSIGN.
{}

assign_op ::= MINUS_ASSIGN.
{}

assign_op ::= LEFT_SHIFT_ASSIGN.
{}

assign_op ::= RIGHT_SHIFT_ASSIGN.
{}

assign_op ::= ZERO_RIGHT_SHIFT_ASSIGN.
{}

assign_op ::= BITWISE_AND_ASSIGN.
{}

assign_op ::= BITWISE_XOR_ASSIGN.
{}

assign_op ::= BITWISE_OR_ASSIGN.
{}

/* Rule 'expr' */

expr ::= assign_expr.
{}

expr ::= expr COMMA assign_expr.
{}

/* Rule 'expr_no_fn' */

expr_no_fn ::= assign_expr_no_fn.
{}

expr_no_fn ::= expr_no_fn COMMA assign_expr.
{}

/* Rule 'expr_no_in' */

expr_no_in ::= assign_expr_no_in.
{}

expr_no_in ::= expr_no_in COMMA assign_expr_no_in.
{}

/* Rule 'literal' */

literal ::= LIT_NULL.
{}

literal ::= LIT_UNDEFINED.
{}

literal ::= LIT_TRUE.
{}

literal ::= LIT_FALSE.
{}

literal ::= NUMBER.
{}

literal ::= STRING.
{}

literal ::= REGEXP.
{}

/* Rule 'array' */

array ::= LBRACKET RBRACKET.
{}

array ::= LBRACKET array_elision RBRACKET.
{}

array ::= LBRACKET array_element_list RBRACKET.
{}

array ::= LBRACKET array_element_list COMMA RBRACKET.
{}

array ::= LBRACKET array_element_list COMMA array_elision RBRACKET.
{}

/* Rule 'array_elision' */

array_elision ::= COMMA.
{}

array_elision ::= array_elision COMMA.
{}

/* Rule 'array_element_list' */

array_element_list ::= assign_expr.
{}

array_element_list ::= array_elision assign_expr.
{}

array_element_list ::= array_element_list COMMA assign_expr.
{}

array_element_list ::= array_element_list COMMA array_elision assign_expr.
{}

/* Rule 'object' */

object ::= LBRACE RBRACE.
{}

object ::= LBRACE object_properties RBRACE.
{}

object ::= LBRACE object_properties COMMA RBRACE.
{}

/* Rule 'object_properties' */

object_properties ::= object_property.
{}

object_properties ::= object_properties COMMA object_property.
{}

/* Rule 'object_property' */

object_property ::= object_property_name COLON assign_expr.
{}

object_property ::= GET object_property_name LPAREN RPAREN LBRACE function_body RBRACE.
{}

object_property ::= GET object_property_name LPAREN object_property_set_params RPAREN LBRACE function_body RBRACE.
{}

/* Rule 'object_property_name' */

object_property_name ::= ident_name.
{}

object_property_name ::= STRING.
{}

object_property_name ::= NUMBER.
{}

/* Rule 'object_property_set_params' */

object_property_set_params ::= IDENT.
{}

/* Rule 'arguments' */

arguments ::= LPAREN RPAREN.
{}

arguments ::= LPAREN arguments_list RPAREN.
{}

/* Rule 'arguments_list' */

arguments_list ::= assign_expr.
{}

arguments_list ::= arguments_list COMMA assign_expr.
{}

%token_prefix       ECMA_TOKEN_TYPE_
%token_type         { lex::Token * }
%extra_argument     { parser::Parser *parser }
%name               ecma_parse

%include
{
    #include <cassert>
    #include <cstdio>
    #include <memory>
    #include <vector>
    #include <string>
    #include "ecma/lex/token.h"
    #include "ecma/parser/parser.h"
    #include "ecma/parser/error.h"
    #include "ecma/utils/messages.h"

    #include "ecma/ast/ast.h"

    using namespace ecma;
    using namespace ecma::ast;
}

%syntax_error {
    parser::ParsingError error("Unexpected token: " + TOKEN->toString(), TOKEN);
    utils::Messages::ReportError(error.message(), TOKEN->pos(), TOKEN->length() > 0 ? TOKEN->length() - 1 : 0);
}

%token_destructor {
    delete $$;
}

%left INSTANCEOF CONTINUE DEBUGGER FUNCTION DEFAULT FINALLY DELETE RETURN SWITCH TYPEOF BREAK CATCH THROW WHILE CASE THIS VOID WITH FOR GET NEW SET TRY VAR DO IN.
%right ELSE IF.
%left EXTENDS EXPORT IMPORT CLASS CONST SUPER ENUM.
%left IMPLEMENTS INTERFACE PROTECTED PACKAGE PRIVATE PUBLIC STATIC YIELD LET.
%left NATIVE.
%left ZERO_RIGHT_SHIFT_ASSIGN STRICT_EQUAL STRICT_NOT_EQUAL ZERO_RIGHT_SHIFT LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN LESSER_EQ GREATER_EQ EQUAL NOT_EQUAL INCREMENT DECREMENT LEFT_SHIFT RIGHT_SHIFT LOGIC_AND LOGIC_OR PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET DOT SEMICOLON COMMA QUESTION COLON LESSER GREATER PLUS MINUS MUL MOD DIV BITWISE_AND BITWISE_OR BITWISE_XOR ASSIGN NOT INV.
%left LIT_FALSE LIT_NULL LIT_TRUE.
%left REGEXP STRING NUMBER IDENT.

/* Rule 'module' */
%start_symbol module
%destructor module { delete $$; }

module ::= .
{
}

module ::= source_elements(A).
{
    for (auto it = A->begin(); it != A->end(); ++it)
    {
        parser->module()->statements().push_back(std::move(*it));
    }

    delete A;
}

/* Rule 'ident' */
%type ident { expr::Ident * }
%destructor ident { delete $$; }

ident(B) ::= IDENT(A).
{
    B = new expr::Ident(A->text());
    B->element(A);

    delete A;
}

ident(B) ::= SET(A).
{
    B = new expr::Ident(A->text());
    B->element(A);

    delete A;
}

ident(B) ::= GET(A).
{
    B = new expr::Ident(A->text());
    B->element(A);

    delete A;
}

ident(B) ::= NATIVE(A).
{
    B = new expr::Ident(A->text());
    B->element(A);

    delete A;
}

/* Rule 'var_typename' */
%type var_typename { expr::Ident * }
%destructor var_typename { delete $$; }

var_typename(B) ::= IDENT(A).
{
    B = new expr::Ident(A->text());
    B->element(A);

    delete A;
}

var_typename(B) ::= VOID(A).
{
    B = new expr::Ident(A->text());
    B->element(A);

    delete A;
}

var_typename(C) ::= MUL(B) var_typename(A).
{
    C = new expr::Ident("*" + A->name());
    C->element(B, A);

    delete B;
    delete A;
}

/* Rule 'var_type' */
%type var_type { expr::Ident * }
%destructor var_type { delete $$; }

var_type(B) ::= COLON(C) var_typename(A).
{
    B = A;

    delete C;
}

var_type(A) ::= .
{
    A = new expr::Ident("");
}

/* Rule 'function_decl' */
%type function_decl { stmt::decl::Function * }
%destructor function_decl { delete $$; }

function_decl(E) ::= FUNCTION(D) ident(C) LPAREN(F) RPAREN(G) LBRACE(H) function_body(B) RBRACE(A).
{
    auto func = new expr::Function(C->name());

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        func->body().push_back(std::move(*it));
    }

    E = new stmt::decl::Function(func);
    E->element(D, A);

    delete D;
    delete C;
    delete F;
    delete G;
    delete H;
    delete B;
    delete A;
}

function_decl(F) ::= FUNCTION(E) ident(D) LPAREN(G) formal_params(C) RPAREN(H) LBRACE(I) function_body(B) RBRACE(A).
{
    auto func = new expr::Function(D->name());

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        func->args().push_back(std::move(*it));
    }

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        func->body().push_back(std::move(*it));
    }

    F = new stmt::decl::Function(func);
    F->element(E, A);

    delete E;
    delete D;
    delete G;
    delete C;
    delete H;
    delete I;
    delete B;
    delete A;
}

/* Rule 'function_expr' */
%type function_expr { expr::Function * }
%destructor function_expr { delete $$; }

function_expr(E) ::= FUNCTION(D) ident(C) LPAREN(F) RPAREN(G) LBRACE(H) function_body(B) RBRACE(A).
{
    E = new expr::Function(C->name());

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        E->body().push_back(std::move(*it));
    }

    E->element(D, A);

    delete D;
    delete C;
    delete F;
    delete G;
    delete H;
    delete B;
    delete A;
}

function_expr(F) ::= FUNCTION(E) ident(D) LPAREN(G) formal_params(C) RPAREN(H) LBRACE(I) function_body(B) RBRACE(A).
{
    F = new expr::Function(D->name());

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        F->args().push_back(std::move(*it));
    }

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        F->body().push_back(std::move(*it));
    }

    F->element(E, A);

    delete E;
    delete D;
    delete G;
    delete C;
    delete H;
    delete I;
    delete B;
    delete A;
}

function_expr(D) ::= FUNCTION(C) LPAREN(E) RPAREN(F) LBRACE(G) function_body(B) RBRACE(A).
{
    D = new expr::Function("");

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->body().push_back(std::move(*it));
    }

    D->element(C, A);

    delete B;

    delete C;
    delete E;
    delete F;
    delete G;
    delete A;
}

function_expr(E) ::= FUNCTION(D) LPAREN(F) formal_params(C) RPAREN(G) LBRACE(H) function_body(B) RBRACE(A).
{
    E = new expr::Function("");

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        E->args().push_back(std::move(*it));
    }

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        E->body().push_back(std::move(*it));
    }

    E->element(D, A);

    delete D;
    delete F;
    delete C;
    delete G;
    delete H;
    delete B;
    delete A;
}

function_expr(D) ::= NATIVE(C) FUNCTION(E) ident(B) LPAREN(F) RPAREN(G) COLON(H) var_typename(A).
{
    D = new expr::Function(B->name());
    D->native(true);
    D->ret_type(A->name());

    D->element(C, A);

    delete C;
    delete E;
    delete B;
    delete F;
    delete G;
    delete H;
    delete A;
}

function_expr(E) ::= NATIVE(D) FUNCTION(F) ident(C) LPAREN(G) formal_params_native(B) RPAREN(H) COLON(I) var_typename(A).
{
    E = new expr::Function(C->name());
    E->native(true);
    E->ret_type(A->name());

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        E->args().push_back(std::move(*it));
    }

    E->element(D, A);

    delete D;
    delete F;
    delete C;
    delete G;
    delete B;
    delete H;
    delete I;
    delete A;
}

/* Rule 'formal_params' */
%type formal_params { std::vector<std::unique_ptr<expr::func::FunctionParam>> * }
%destructor formal_params { delete $$; }

formal_params(B) ::= formal_param(A).
{
    B = new std::vector<std::unique_ptr<expr::func::FunctionParam>>();
    B->push_back(std::unique_ptr<expr::func::FunctionParam>(A));
}

formal_params(C) ::= formal_params(B) COMMA(D) formal_param(A).
{
    C = B;
    C->push_back(std::unique_ptr<expr::func::FunctionParam>(A));

    delete D;
}

/* Rule 'formal_param' */
%type formal_param { expr::func::FunctionParam * }
%destructor formal_param { delete $$; }

formal_param(C) ::= ident(B) var_type(A).
{
    C = new expr::func::FunctionParam(B->name());
    C->type(A->name());
    C->element(B, A);

    delete B;
    delete A;
}

/* Rule 'formal_params_native' */
%type formal_params_native { std::vector<std::unique_ptr<expr::func::FunctionParam>> * }
%destructor formal_params_native { delete $$; }

formal_params_native(B) ::= formal_param_native(A).
{
    B = new std::vector<std::unique_ptr<expr::func::FunctionParam>>();
    B->push_back(std::unique_ptr<expr::func::FunctionParam>(A));
}

formal_params_native(C) ::= formal_params(B) COMMA(D) formal_param_native(A).
{
    C = B;
    C->push_back(std::unique_ptr<expr::func::FunctionParam>(A));

    delete D;
}

/* Rule 'formal_param_native' */
%type formal_param_native { expr::func::FunctionParam * }
%destructor formal_param_native { delete $$; }

formal_param_native(C) ::= ident(B) COLON(D) var_typename(A).
{
    C = new expr::func::FunctionParam(B->name());
    C->type(A->name());
    C->element(B, A);

    delete B;
    delete D;
    delete A;
}

/* Rule 'function_body' */
%type function_body { std::vector<std::unique_ptr<Statement>> * }
%destructor function_body { delete $$; }

function_body(A) ::= .
{
    A = new std::vector<std::unique_ptr<Statement>>();
}

function_body(B) ::= source_elements(A).
{
    B = A;
}

/* Rule 'source_elements' */
%type source_elements { std::vector<std::unique_ptr<Statement>> * }
%destructor source_elements { delete $$; }

source_elements(B) ::= source_element(A).
{
    B = new std::vector<std::unique_ptr<Statement>>();
    B->push_back(std::unique_ptr<Statement>(A));
}

source_elements(C) ::= source_elements(B) source_element(A).
{
    C = B;
    C->push_back(std::unique_ptr<Statement>(A));
}

/* Rule 'source_element' */
%type source_element { Statement * }
%destructor source_element { delete $$; }

source_element(B) ::= stmt(A).
{
    B = A;
}

source_element(B) ::= function_decl(A).
{
    B = A;
}

/* Rule 'stmt' */
%type stmt { Statement * }
%destructor stmt { delete $$; }

stmt(B) ::= block(A).
{
    B = A;
}

stmt(B) ::= var_stmt(A).
{
    B = A;
}

stmt(A) ::= empty_stmt.
{
    A = new Statement();
}

stmt(B) ::= expr_stmt(A).
{
    B = A;
}

stmt(B) ::= if_stmt(A).
{
    B = A;
}

stmt(B) ::= iter_stmt(A).
{
    B = A;
}

stmt(B) ::= cont_stmt(A).
{
    B = A;
}

stmt(B) ::= break_stmt(A).
{
    B = A;
}

stmt(B) ::= return_stmt(A).
{
    B = A;
}

stmt(B) ::= with_stmt(A).
{
    B = A;
}

stmt(B) ::= switch_stmt(A).
{
    B = A;
}

stmt(B) ::= throw_stmt(A).
{
    B = A;
}

stmt(B) ::= try_stmt(A).
{
    B = A;
}

stmt(B) ::= debug_stmt(A).
{
    B = A;
}

/* Rule 'block' */
%type block { stmt::Block * }
%destructor block { delete $$; }

block(D) ::= LBRACE(C) stmt_list(B) RBRACE(A).
{
    D = new stmt::Block();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->statements().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

/* Rule 'block_empty' */
%type block_empty { stmt::Block * }
%destructor block_empty { delete $$; }

block_empty(C) ::= LBRACE(B) RBRACE(A).
{
    C = new stmt::Block();
    C->element(B, A);

    delete B;
    delete A;
}

/* Rule 'block_stmt' */
%type block_stmt { stmt::Block * }
%destructor block_stmt { delete $$; }

block_stmt(B) ::= block(A).
{
    B = A;
}

block_stmt(B) ::= block_empty(A).
{
    B = A;
}

/* Rule 'stmt_list' */
%type stmt_list { std::vector<std::unique_ptr<Statement>> * }
%destructor stmt_list { delete $$; }

stmt_list(B) ::= stmt(A).
{
    B = new std::vector<std::unique_ptr<Statement>>();
    B->push_back(std::unique_ptr<Statement>(A));
}

stmt_list(C) ::= stmt_list(B) stmt(A).
{
    C = B;
    C->push_back(std::unique_ptr<Statement>(A));
}

/* Rule 'var_stmt' */
%type var_stmt { stmt::decl::Vars * }
%destructor var_stmt { delete $$; }

var_stmt(D) ::= VAR(C) var_decls(B) SEMICOLON(A).
{
    D = new stmt::decl::Vars();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->decls().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

/* Rule 'var_decls' */
%type var_decls { std::vector<std::unique_ptr<stmt::decl::Var>> * }
%destructor var_decls { delete $$; }

var_decls(B) ::= var_decl(A).
{
    B = new std::vector<std::unique_ptr<stmt::decl::Var>>();
    B->push_back(std::unique_ptr<stmt::decl::Var>(A));
}

var_decls(C) ::= var_decls(B) COMMA(D) var_decl(A).
{
    C = B;
    C->push_back(std::unique_ptr<stmt::decl::Var>(A));

    delete D;
}

/* Rule 'var_decls_no_in' */
%type var_decls_no_in { std::vector<std::unique_ptr<stmt::decl::Var>> * }
%destructor var_decls_no_in { delete $$; }

var_decls_no_in(B) ::= var_decl_no_in(A).
{
    B = new std::vector<std::unique_ptr<stmt::decl::Var>>();
    B->push_back(std::unique_ptr<stmt::decl::Var>(A));
}

var_decls_no_in(C) ::= var_decls_no_in(B) COMMA(D) var_decl_no_in(A).
{
    C = B;
    C->push_back(std::unique_ptr<stmt::decl::Var>(A));

    delete D;
}

/* Rule 'var_decl' */
%type var_decl { stmt::decl::Var * }
%destructor var_decl { delete $$; }

var_decl(C) ::= ident(B) var_type(A).
{
    C = new stmt::decl::Var(B->name());
    C->type(A->name());
    C->element(B, A);

    delete B;
    delete A;
}

var_decl(D) ::= ident(C) var_type(B) init(A).
{
    D = new stmt::decl::Var(C->name());
    D->init(A);
    D->type(B->name());
    D->element(C, A);

    delete C;
    delete B;
}

/* Rule 'var_decl_no_in' */
%type var_decl_no_in { stmt::decl::Var * }
%destructor var_decl_no_in { delete $$; }

var_decl_no_in(C) ::= ident(B) var_type(A).
{
    C = new stmt::decl::Var(B->name());
    C->type(A->name());
    C->element(B, A);

    delete B;
    delete A;
}

var_decl_no_in(D) ::= ident(C) var_type(B) init_no_in(A).
{
    D = new stmt::decl::Var(C->name());
    D->init(A);
    D->type(B->name());
    D->element(C, A);

    delete C;
    delete B;
}

/* Rule 'init' */
%type init { Expression * }
%destructor init { delete $$; }

init(B) ::= ASSIGN(C) assign_expr(A).
{
    B = A;

    delete C;
}

/* Rule 'init_no_in' */
%type init_no_in { Expression * }
%destructor init_no_in { delete $$; }

init_no_in(B) ::= ASSIGN(C) assign_expr_no_in(A).
{
    B = A;

    delete C;
}

/* Rule 'empty_stmt' */
%destructor empty_stmt { delete $$; }

empty_stmt ::= SEMICOLON(A).
{
    delete A;
}

/* Rule 'expr_stmt' */
%type expr_stmt { stmt::ExpressionStmt * }
%destructor expr_stmt { delete $$; }

expr_stmt(C) ::= expr_no_fn(B) SEMICOLON(A).
{
    C = new stmt::ExpressionStmt(B);
    C->element(B, A);

    delete A;
}

/* Rule 'if_stmt' */
%type if_stmt { stmt::ctrl::If * }
%destructor if_stmt { delete $$; }

if_stmt(D) ::= IF(C) LPAREN(E) expr(B) RPAREN(F) stmt(A).
{
    D = new stmt::ctrl::If(B, A);
    D->element(C, A);

    delete C;
    delete E;
    delete F;
}

if_stmt(E) ::= IF(D) LPAREN(F) expr(C) RPAREN(G) stmt(B) ELSE(H) stmt(A).
{
    E = new stmt::ctrl::If(C, B);
    E->else_stmt(A);
    E->element(D, A);

    delete D;
    delete F;
    delete G;
    delete H;
}

/* Rule 'iter_stmt' */
%type iter_stmt { Statement * }
%destructor iter_stmt { delete $$; }

iter_stmt(B) ::= while_stmt(A).
{
    B = A;
}

iter_stmt(B) ::= for_stmt(A).
{
    B = A;
}

iter_stmt(B) ::= for_in_stmt(A).
{
    B = A;
}

/* Rule 'while_stmt' */
%type while_stmt { stmt::ctrl::While * }
%destructor while_stmt { delete $$; }

while_stmt(D) ::= WHILE(C) LPAREN(E) expr(B) RPAREN(F) stmt(A).
{
    D = new stmt::ctrl::While(false, B, A);
    D->element(C, A);

    delete C;
    delete E;
    delete F;
}

while_stmt(E) ::= DO(D) stmt(C) WHILE(F) LPAREN(G) expr(B) RPAREN(A).
{
    E = new stmt::ctrl::While(true, B, C);
    E->element(D, A);

    delete D;
    delete F;
    delete G;
    delete A;
}

/* Rule 'for_stmt' */
%type for_stmt { stmt::ctrl::For * }
%destructor for_stmt { delete $$; }

for_stmt(F) ::= FOR(E) LPAREN(G) for_init(D) SEMICOLON(H) for_cond(C) SEMICOLON(I) for_loop(B) RPAREN(J) stmt(A).
{
    F = new stmt::ctrl::For(D, C, B, A);
    F->element(E, A);

    delete E;
    delete G;
    delete H;
    delete I;
    delete J;
}

/* Rule 'for_init' */
%type for_init { Statement * }
%destructor for_init { delete $$; }

for_init(A) ::= .
{
    A = nullptr;
}

for_init(B) ::= expr_no_in(A).
{
    B = new stmt::ExpressionStmt(A);
    B->element(A);
}

for_init(B) ::= VAR(C) var_decls_no_in(A).
{
    auto vars = new stmt::decl::Vars();

    for (auto it = A->begin(); it != A->end(); ++it)
    {
        vars->decls().push_back(std::move(*it));
    }

    B = vars;

    delete C;
    delete A;
}

/* Rule 'for_cond' */
%type for_cond { Statement * }
%destructor for_cond { delete $$; }

for_cond(A) ::= .
{
    A = nullptr;
}

for_cond(B) ::= expr(A).
{
    B = new stmt::ExpressionStmt(A);
    B->element(A);
}

/* Rule 'for_loop' */
%type for_loop { Statement * }
%destructor for_loop { delete $$; }

for_loop(A) ::= .
{
    A = nullptr;
}

for_loop(B) ::= expr(A).
{
    B = new stmt::ExpressionStmt(A);
    B->element(A);
}

/* Rule 'for_in_stmt' */
%type for_in_stmt { stmt::ctrl::ForIn * }
%destructor for_in_stmt { delete $$; }

for_in_stmt(E) ::= FOR(D) LPAREN(F) left_hand_expr(C) IN(G) expr(B) RPAREN(H) stmt(A).
{
    E = new stmt::ctrl::ForIn(C, B, A);
    E->element(D, A);

    delete D;
    delete F;
    delete G;
    delete H;
}

for_in_stmt(E) ::= FOR(D) LPAREN(F) VAR(G) var_decl_no_in(C) IN(H) expr(B) RPAREN(I) stmt(A).
{
    E = new stmt::ctrl::ForIn(new expr::Ident(C->name()), B, A);
    E->init(C->take_init());
    E->element(D, A);

    delete C;

    delete D;
    delete F;
    delete G;
    delete H;
    delete I;
}

/* Rule 'cont_stmt' */
%type cont_stmt { stmt::ctrl::Continue * }
%destructor cont_stmt { delete $$; }

cont_stmt(C) ::= CONTINUE(B) SEMICOLON(A).
{
    C = new stmt::ctrl::Continue();
    C->element(B, A);

    delete B;
    delete A;
}

cont_stmt(D) ::= CONTINUE(C) ident(B) SEMICOLON(A).
{
    D = new stmt::ctrl::Continue();
    D->name(B->name());
    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

/* Rule 'break_stmt' */
%type break_stmt { stmt::ctrl::Break * }
%destructor break_stmt { delete $$; }

break_stmt(C) ::= BREAK(B) SEMICOLON(A).
{
    C = new stmt::ctrl::Break();
    C->element(B, A);

    delete B;
    delete A;
}

break_stmt(D) ::= BREAK(C) ident(B) SEMICOLON(A).
{
    D = new stmt::ctrl::Break();
    D->name(new std::string(B->name()));
    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

/* Rule 'return_stmt' */
%type return_stmt { stmt::ctrl::Return * }
%destructor return_stmt { delete $$; }

return_stmt(C) ::= RETURN(B) SEMICOLON(A).
{
    C = new stmt::ctrl::Return();
    C->element(B, A);

    delete B;
    delete A;
}

return_stmt(D) ::= RETURN(C) expr(B) SEMICOLON(A).
{
    D = new stmt::ctrl::Return();
    D->expr(B);
    D->element(C, A);

    delete C;
    delete A;
}

/* Rule 'with_stmt' */
%type with_stmt { stmt::ctrl::With * }
%destructor with_stmt { delete $$; }

with_stmt(D) ::= WITH(C) LPAREN(E) expr(B) RPAREN(F) stmt(A).
{
    D = new stmt::ctrl::With(B, A);
    D->element(C, A);

    delete C;
    delete E;
    delete F;
}

/* Rule 'switch_stmt' */
%type switch_stmt { stmt::ctrl::Switch * }
%destructor switch_stmt { delete $$; }

switch_stmt(D) ::= SWITCH(C) LPAREN(E) expr(B) RPAREN(F) case_block(A).
{
    D = new stmt::ctrl::Switch(B);

    for (auto it = A->cases().begin(); it != A->cases().end(); ++it)
    {
        D->cases().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete E;
    delete F;
    delete A;
}

/* Rule 'case_block' */
%type case_block { stmt::ctrl::CaseBlock * }
%destructor case_block { delete $$; }

case_block(A) ::= LBRACE(B) RBRACE(C).
{
    A = new stmt::ctrl::CaseBlock();

    delete B;
    delete C;
}

case_block(D) ::= LBRACE(C) case_clauses(B) RBRACE(A).
{
    D = new stmt::ctrl::CaseBlock();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->cases().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

/* Rule 'case_clauses' */
%type case_clauses { std::vector<std::unique_ptr<stmt::ctrl::Case>> * }
%destructor case_clauses { delete $$; }

case_clauses(B) ::= case_clause(A).
{
    B = new std::vector<std::unique_ptr<stmt::ctrl::Case>>();
    B->push_back(std::unique_ptr<stmt::ctrl::Case>(A));
}

case_clauses(C) ::= case_clauses(B) case_clause(A).
{
    C = B;
    C->push_back(std::unique_ptr<stmt::ctrl::Case>(A));
}

/* Rule 'case_clause' */
%type case_clause { stmt::ctrl::Case * }
%destructor case_clause { delete $$; }

case_clause(C) ::= case_key(B) COLON(A).
{
    C = new stmt::ctrl::Case(B);
    C->element(B, A);

    delete A;
}

case_clause(C) ::= case_key(B) COLON(D) stmt_list(A).
{
    C = new stmt::ctrl::Case(B);

    for (auto it = A->begin(); it != A->end(); ++it)
    {
        C->actions().push_back(std::move(*it));
    }

    delete D;
    delete A;
}

/* Rule 'case_key' */
%type case_key { stmt::ctrl::CaseKey * }
%destructor case_key { delete $$; }

case_key(C) ::= CASE(B) expr(A).
{
    C = new stmt::ctrl::CaseKey();
    C->expr(A);
    C->element(B, A);

    delete B;
}

case_key(B) ::= DEFAULT(A).
{
    B = new stmt::ctrl::CaseKey();
    B->element(A);

    delete A;
}

/* Rule 'throw_stmt' */
%type throw_stmt { stmt::ctrl::Throw * }
%destructor throw_stmt { delete $$; }

throw_stmt(D) ::= THROW(C) expr(B) SEMICOLON(A).
{
    D = new stmt::ctrl::Throw(B);
    D->element(C, A);

    delete C;
    delete A;
}

/* Rule 'try_stmt' */
%type try_stmt { stmt::ctrl::Try * }
%destructor try_stmt { delete $$; }

try_stmt(D) ::= TRY(C) block_stmt(B) catch(A).
{
    D = new stmt::ctrl::Try(B);
    D->catch_action(A);
    D->element(C, A);

    delete C;
}

try_stmt(D) ::= TRY(C) block_stmt(B) finally(A).
{
    D = new stmt::ctrl::Try(B);
    D->finally_action(A);
    D->element(C, A);

    delete C;
}

try_stmt(E) ::= TRY(D) block_stmt(C) catch(B) finally(A).
{
    E = new stmt::ctrl::Try(C);
    E->catch_action(B);
    E->finally_action(A);
    E->element(D, A);

    delete D;
}

/* Rule 'catch' */
%type catch { stmt::ctrl::Catch * }
%destructor catch { delete $$; }

catch(D) ::= CATCH(C) LPAREN(E) ident(B) RPAREN(F) block_stmt(A).
{
    D = new stmt::ctrl::Catch(B->name(), A);
    D->element(C, A);

    delete C;
    delete E;
    delete B;
    delete F;
}

/* Rule 'finally' */
%type finally { stmt::ctrl::Finally * }
%destructor finally { delete $$; }

finally(C) ::= FINALLY(B) block_stmt(A).
{
    C = new stmt::ctrl::Finally(A);
    C->element(B, A);

    delete B;
}

/* Rule 'debug_stmt' */
%type debug_stmt { stmt::Debug * }
%destructor debug_stmt { delete $$; }

debug_stmt(C) ::= DEBUGGER(B) SEMICOLON(A).
{
    C = new stmt::Debug();
    C->element(B, A);

    delete B;
    delete A;
}

/* Rule 'primary_expr' */
%type primary_expr { Expression * }
%destructor primary_expr { delete $$; }

primary_expr(B) ::= THIS(A).
{
    B = new expr::This();
    B->element(A);

    delete A;
}

primary_expr(B) ::= ident(A).
{
    B = A;
    B->element(A);
}

primary_expr(B) ::= literal(A).
{
    B = A;
}

primary_expr(B) ::= array(A).
{
    B = A;
}

primary_expr(B) ::= object(A).
{
    B = A;
}

primary_expr(B) ::= LPAREN(C) expr(A) RPAREN(D).
{
    B = A;

    delete C;
    delete D;
}

/* Rule 'member_expr' */
%type member_expr { Expression * }
%destructor member_expr { delete $$; }

member_expr(B) ::= primary_expr(A).
{
    B = A;
}

member_expr(B) ::= function_expr(A).
{
    B = A;
}

member_expr(D) ::= member_expr(C) LBRACKET(E) expr(B) RBRACKET(A).
{
    auto index = new expr::Index();
    index->expr(C);
    index->index(B);

    D = index;
    D->element(C, A);

    delete E;
    delete A;
}

member_expr(C) ::= member_expr(B) DOT(D) ident(A).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(A->name());

    C = member;
    C->element(B, A);

    delete D;
    delete A;
}

member_expr(D) ::= NEW(C) member_expr(B) arguments(A).
{
    auto new_expr = new expr::New();
    new_expr->expr(B);

    for(auto it = A->elements().begin(); it != A->elements().end(); ++it)
    {
        new_expr->args().push_back(std::move(*it));
    }

    D = new_expr;
    D->element(C, A);

    delete C;
    delete A;
}

/* Rule 'member_expr_no_fn' */
%type member_expr_no_fn { Expression * }
%destructor member_expr_no_fn { delete $$; }

member_expr_no_fn(B) ::= primary_expr(A).
{
    B = A;
}

member_expr_no_fn(D) ::= member_expr_no_fn(C) LBRACKET(E) expr(B) RBRACKET(A).
{
    auto index = new expr::Index();
    index->expr(C);
    index->index(B);

    D = index;
    D->element(C, A);

    delete E;
    delete A;
}

member_expr_no_fn(C) ::= member_expr_no_fn(B) DOT(D) ident(A).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(A->name());

    C = member;
    C->element(B, A);

    delete D;
    delete A;
}

member_expr_no_fn(D) ::= NEW(C) member_expr(B) arguments(A).
{
    auto new_expr = new expr::New();
    new_expr->expr(B);

    for(auto it = A->elements().begin(); it != A->elements().end(); ++it)
    {
        new_expr->args().push_back(std::move(*it));
    }

    D = new_expr;
    D->element(C, A);

    delete C;
    delete A;
}

/* Rule 'new_expr' */
%type new_expr { Expression * }
%destructor new_expr { delete $$; }

new_expr(B) ::= member_expr(A).
{
    B = A;
}

new_expr(C) ::= NEW(B) new_expr(A).
{
    auto new_expr = new expr::New();
    new_expr->expr(A);

    C = new_expr;
    C->element(B, A);

    delete B;
}

/* Rule 'new_expr_no_fn' */
%type new_expr_no_fn { Expression * }
%destructor new_expr_no_fn { delete $$; }

new_expr_no_fn(B) ::= member_expr_no_fn(A).
{
    B = A;
}

new_expr_no_fn(C) ::= NEW(B) new_expr(A).
{
    auto new_expr = new expr::New();
    new_expr->expr(A);

    C = new_expr;
    C->element(B, A);

    delete B;
}

/* Rule 'call_expr' */
%type call_expr { Expression * }
%destructor call_expr { delete $$; }

call_expr(C) ::= member_expr(B) arguments(A).
{
    auto call = new expr::Call(B);

    for(auto it = A->elements().begin(); it != A->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    C = call;
    C->element(B, A);

    delete A;
}

call_expr(C) ::= call_expr(B) arguments(A).
{
    auto call = new expr::Call(B);

    for(auto it = A->elements().begin(); it != A->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    C = call;
    C->element(B, A);

    delete A;
}

call_expr(D) ::= call_expr(C) LBRACKET(E) expr(B) RBRACKET(A).
{
    auto index = new expr::Index();
    index->expr(C);
    index->index(B);

    D = index;
    D->element(C, A);

    delete E;
    delete A;
}

call_expr(C) ::= call_expr(B) DOT(D) ident(A).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(A->name());

    C = member;
    C->element(B, A);

    delete D;
    delete A;
}

/* Rule 'call_expr_no_fn' */
%type call_expr_no_fn { Expression * }
%destructor call_expr_no_fn { delete $$; }

call_expr_no_fn(C) ::= member_expr_no_fn(B) arguments(A).
{
    auto call = new expr::Call(B);

    for(auto it = A->elements().begin(); it != A->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    C = call;
    C->element(B, A);

    delete A;
}

call_expr_no_fn(C) ::= call_expr_no_fn(B) arguments(A).
{
    auto call = new expr::Call(B);

    for(auto it = A->elements().begin(); it != A->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    C = call;
    C->element(B, A);

    delete A;
}

call_expr_no_fn(D) ::= call_expr_no_fn(C) LBRACKET(E) expr(B) RBRACKET(A).
{
    auto index = new expr::Index();
    index->expr(C);
    index->index(B);

    D = index;
    D->element(C, A);

    delete E;
    delete A;
}

call_expr_no_fn(C) ::= call_expr_no_fn(B) DOT(D) ident(A).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(A->name());

    C = member;
    C->element(B, A);

    delete D;
    delete A;
}

/* Rule 'left_hand_expr' */
%type left_hand_expr { Expression * }
%destructor left_hand_expr { delete $$; }

left_hand_expr(B) ::= new_expr(A).
{
    B = A;
}

left_hand_expr(B) ::= call_expr(A).
{
    B = A;
}

/* Rule 'left_hand_expr_no_fn' */
%type left_hand_expr_no_fn { Expression * }
%destructor left_hand_expr_no_fn { delete $$; }

left_hand_expr_no_fn(B) ::= new_expr_no_fn(A).
{
    B = A;
}

left_hand_expr_no_fn(B) ::= call_expr_no_fn(A).
{
    B = A;
}

/* Rule 'postfix_expr' */
%type postfix_expr { Expression * }
%destructor postfix_expr { delete $$; }

postfix_expr(B) ::= left_hand_expr(A).
{
    B = A;
}

postfix_expr(C) ::= left_hand_expr(B) INCREMENT(A).
{
    C = new expr::Postfix(B, expr::Postfix::OpType::INCREMENT);
    C->element(B, A);

    delete A;
}

postfix_expr(C) ::= left_hand_expr(B) DECREMENT(A).
{
    C = new expr::Postfix(B, expr::Postfix::OpType::DECREMENT);
    C->element(B, A);

    delete A;
}

/* Rule 'postfix_expr_no_fn' */
%type postfix_expr_no_fn { Expression * }
%destructor postfix_expr_no_fn { delete $$; }

postfix_expr_no_fn(B) ::= left_hand_expr_no_fn(A).
{
    B = A;
}

postfix_expr_no_fn(C) ::= left_hand_expr_no_fn(B) INCREMENT(A).
{
    C = new expr::Postfix(B, expr::Postfix::OpType::INCREMENT);
    C->element(B, A);

    delete A;
}

postfix_expr_no_fn(C) ::= left_hand_expr_no_fn(B) DECREMENT(A).
{
    C = new expr::Postfix(B, expr::Postfix::OpType::DECREMENT);
    C->element(B, A);

    delete A;
}

/* Rule 'unary_expr' */
%type unary_expr { Expression * }
%destructor unary_expr { delete $$; }

unary_expr(B) ::= postfix_expr(A).
{
    B = A;
}

unary_expr(C) ::= DELETE(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::DELETE);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= VOID(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::VOID);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= TYPEOF(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::TYPEOF);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= INCREMENT(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::INCREMENT);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= DECREMENT(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::DECREMENT);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= PLUS(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::PLUS);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= MINUS(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::MINUS);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= INV(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::INV);
    C->element(B, A);

    delete B;
}

unary_expr(C) ::= NOT(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::NOT);
    C->element(B, A);

    delete B;
}

/* Rule 'unary_expr_no_fn' */
%type unary_expr_no_fn { Expression * }
%destructor unary_expr_no_fn { delete $$; }

unary_expr_no_fn(B) ::= postfix_expr_no_fn(A).
{
    B = A;
}

unary_expr_no_fn(C) ::= DELETE(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::DELETE);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= VOID(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::VOID);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= TYPEOF(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::TYPEOF);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= INCREMENT(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::INCREMENT);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= DECREMENT(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::DECREMENT);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= PLUS(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::PLUS);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= MINUS(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::MINUS);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= INV(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::INV);
    C->element(B, A);

    delete B;
}

unary_expr_no_fn(C) ::= NOT(B) unary_expr(A).
{
    C = new expr::Unary(A, expr::Unary::OpType::NOT);
    C->element(B, A);

    delete B;
}

/* Rule 'mul_expr' */
%type mul_expr { Expression * }
%destructor mul_expr { delete $$; }

mul_expr(B) ::= unary_expr(A).
{
    B = A;
}

mul_expr(C) ::= mul_expr(B) MUL(D) unary_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::MUL);
    C->element(B, A);

    delete D;
}

mul_expr(C) ::= mul_expr(B) DIV(D) unary_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::DIV);
    C->element(B, A);

    delete D;
}

mul_expr(C) ::= mul_expr(B) MOD(D) unary_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::MOD);
    C->element(B, A);

    delete D;
}

/* Rule 'mul_expr_no_fn' */
%type mul_expr_no_fn { Expression * }
%destructor mul_expr_no_fn { delete $$; }

mul_expr_no_fn(B) ::= unary_expr_no_fn(A).
{
    B = A;
}

mul_expr_no_fn(C) ::= mul_expr_no_fn(B) MUL(D) unary_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::MUL);
    C->element(B, A);

    delete D;
}

mul_expr_no_fn(C) ::= mul_expr_no_fn(B) DIV(D) unary_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::DIV);
    C->element(B, A);

    delete D;
}

mul_expr_no_fn(C) ::= mul_expr_no_fn(B) MOD(D) unary_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::MOD);
    C->element(B, A);

    delete D;
}

/* Rule 'add_expr' */
%type add_expr { Expression * }
%destructor add_expr { delete $$; }

add_expr(B) ::= mul_expr(A).
{
    B = A;
}

add_expr(C) ::= add_expr(B) PLUS(D) mul_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::PLUS);
    C->element(B, A);

    delete D;
}

add_expr(C) ::= add_expr(B) MINUS(D) mul_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::MINUS);
    C->element(B, A);

    delete D;
}

/* Rule 'add_expr_no_fn' */
%type add_expr_no_fn { Expression * }
%destructor add_expr_no_fn { delete $$; }

add_expr_no_fn(B) ::= mul_expr_no_fn(A).
{
    B = A;
}

add_expr_no_fn(C) ::= add_expr_no_fn(B) PLUS(D) mul_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::PLUS);
    C->element(B, A);

    delete D;
}

add_expr_no_fn(C) ::= add_expr_no_fn(B) MINUS(D) mul_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::MINUS);
    C->element(B, A);

    delete D;
}

/* Rule 'shift_expr' */
%type shift_expr { Expression * }
%destructor shift_expr { delete $$; }

shift_expr(B) ::= add_expr(A).
{
    B = A;
}

shift_expr(C) ::= shift_expr(B) LEFT_SHIFT(D) add_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LEFT_SHIFT);
    C->element(B, A);

    delete D;
}

shift_expr(C) ::= shift_expr(B) RIGHT_SHIFT(D) add_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::RIGHT_SHIFT);
    C->element(B, A);

    delete D;
}

shift_expr(C) ::= shift_expr(B) ZERO_RIGHT_SHIFT(D) add_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::ZERO_RIGHT_SHIFT);
    C->element(B, A);

    delete D;
}

/* Rule 'shift_expr_no_fn' */
%type shift_expr_no_fn { Expression * }
%destructor shift_expr_no_fn { delete $$; }

shift_expr_no_fn(B) ::= add_expr_no_fn(A).
{
    B = A;
}

shift_expr_no_fn(C) ::= shift_expr_no_fn(B) LEFT_SHIFT(D) add_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LEFT_SHIFT);
    C->element(B, A);

    delete D;
}

shift_expr_no_fn(C) ::= shift_expr_no_fn(B) RIGHT_SHIFT(D) add_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::RIGHT_SHIFT);
    C->element(B, A);

    delete D;
}

shift_expr_no_fn(C) ::= shift_expr_no_fn(B) ZERO_RIGHT_SHIFT(D) add_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::ZERO_RIGHT_SHIFT);
    C->element(B, A);

    delete D;
}

/* Rule 'rel_expr' */
%type rel_expr { Expression * }
%destructor rel_expr { delete $$; }

rel_expr(B) ::= shift_expr(A).
{
    B = A;
}

rel_expr(C) ::= rel_expr(B) LESSER(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LESSER_THAN);
    C->element(B, A);

    delete D;
}

rel_expr(C) ::= rel_expr(B) GREATER(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::GREATER_THAN);
    C->element(B, A);

    delete D;
}

rel_expr(C) ::= rel_expr(B) LESSER_EQ(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LESSER_EQ_THAN);
    C->element(B, A);

    delete D;
}

rel_expr(C) ::= rel_expr(B) GREATER_EQ(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::GREATER_EQ_THAN);
    C->element(B, A);

    delete D;
}

rel_expr(C) ::= rel_expr(B) INSTANCEOF(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::INSTANCEOF);
    C->element(B, A);

    delete D;
}

rel_expr(C) ::= rel_expr(B) IN(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::IN);
    C->element(B, A);

    delete D;
}

/* Rule 'rel_expr_no_fn' */
%type rel_expr_no_fn { Expression * }
%destructor rel_expr_no_fn { delete $$; }

rel_expr_no_fn(B) ::= shift_expr_no_fn(A).
{
    B = A;
}

rel_expr_no_fn(C) ::= rel_expr_no_fn(B) LESSER(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LESSER_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_fn(C) ::= rel_expr_no_fn(B) GREATER(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::GREATER_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_fn(C) ::= rel_expr_no_fn(B) LESSER_EQ(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LESSER_EQ_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_fn(C) ::= rel_expr_no_fn(B) GREATER_EQ(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::GREATER_EQ_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_fn(C) ::= rel_expr_no_fn(B) INSTANCEOF(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::INSTANCEOF);
    C->element(B, A);

    delete D;
}

rel_expr_no_fn(C) ::= rel_expr_no_fn(B) IN(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::IN);
    C->element(B, A);

    delete D;
}

/* Rule 'rel_expr_no_in' */
%type rel_expr_no_in { Expression * }
%destructor rel_expr_no_in { delete $$; }

rel_expr_no_in(B) ::= shift_expr(A).
{
    B = A;
}

rel_expr_no_in(C) ::= rel_expr_no_in(B) LESSER(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LESSER_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_in(C) ::= rel_expr_no_in(B) GREATER(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::GREATER_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_in(C) ::= rel_expr_no_in(B) LESSER_EQ(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LESSER_EQ_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_in(C) ::= rel_expr_no_in(B) GREATER_EQ(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::GREATER_EQ_THAN);
    C->element(B, A);

    delete D;
}

rel_expr_no_in(C) ::= rel_expr_no_in(B) INSTANCEOF(D) shift_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::INSTANCEOF);
    C->element(B, A);

    delete D;
}

/* Rule 'eq_expr' */
%type eq_expr { Expression * }
%destructor eq_expr { delete $$; }

eq_expr(B) ::= rel_expr(A).
{
    B = A;
}

eq_expr(C) ::= eq_expr(B) EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr(C) ::= eq_expr(B) NOT_EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::NOT_EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr(C) ::= eq_expr(B) STRICT_EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::STRICT_EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr(C) ::= eq_expr(B) STRICT_NOT_EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::STRICT_NOT_EQUAL);
    C->element(B, A);

    delete D;
}

/* Rule 'eq_expr_no_fn' */
%type eq_expr_no_fn { Expression * }
%destructor eq_expr_no_fn { delete $$; }

eq_expr_no_fn(B) ::= rel_expr_no_fn(A).
{
    B = A;
}

eq_expr_no_fn(C) ::= eq_expr_no_fn(B) EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr_no_fn(C) ::= eq_expr_no_fn(B) NOT_EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::NOT_EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr_no_fn(C) ::= eq_expr_no_fn(B) STRICT_EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::STRICT_EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr_no_fn(C) ::= eq_expr_no_fn(B) STRICT_NOT_EQUAL(D) rel_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::STRICT_NOT_EQUAL);
    C->element(B, A);

    delete D;
}

/* Rule 'eq_expr_no_in' */
%type eq_expr_no_in { Expression * }
%destructor eq_expr_no_in { delete $$; }

eq_expr_no_in(B) ::= rel_expr_no_in(A).
{
    B = A;
}

eq_expr_no_in(C) ::= eq_expr_no_in(B) EQUAL(D) rel_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr_no_in(C) ::= eq_expr_no_in(B) NOT_EQUAL(D) rel_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::NOT_EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr_no_in(C) ::= eq_expr_no_in(B) STRICT_EQUAL(D) rel_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::STRICT_EQUAL);
    C->element(B, A);

    delete D;
}

eq_expr_no_in(C) ::= eq_expr_no_in(B) STRICT_NOT_EQUAL(D) rel_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::STRICT_NOT_EQUAL);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_and_expr' */
%type bit_and_expr { Expression * }
%destructor bit_and_expr { delete $$; }

bit_and_expr(B) ::= eq_expr(A).
{
    B = A;
}

bit_and_expr(C) ::= bit_and_expr(B) BITWISE_AND(D) eq_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_AND);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_and_expr_no_fn' */
%type bit_and_expr_no_fn { Expression * }
%destructor bit_and_expr_no_fn { delete $$; }

bit_and_expr_no_fn(B) ::= eq_expr_no_fn(A).
{
    B = A;
}

bit_and_expr_no_fn(C) ::= bit_and_expr_no_fn(B) BITWISE_AND(D) eq_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_AND);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_and_expr_no_in' */
%type bit_and_expr_no_in { Expression * }
%destructor bit_and_expr_no_in { delete $$; }

bit_and_expr_no_in(B) ::= eq_expr_no_in(A).
{
    B = A;
}

bit_and_expr_no_in(C) ::= bit_and_expr_no_in(B) BITWISE_AND(D) eq_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_AND);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_xor_expr' */
%type bit_xor_expr { Expression * }
%destructor bit_xor_expr { delete $$; }

bit_xor_expr(B) ::= bit_and_expr(A).
{
    B = A;
}

bit_xor_expr(C) ::= bit_xor_expr(B) BITWISE_XOR(D) bit_and_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_XOR);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_xor_expr_no_fn' */
%type bit_xor_expr_no_fn { Expression * }
%destructor bit_xor_expr_no_fn { delete $$; }

bit_xor_expr_no_fn(B) ::= bit_and_expr_no_fn(A).
{
    B = A;
}

bit_xor_expr_no_fn(C) ::= bit_xor_expr_no_fn(B) BITWISE_XOR(D) bit_and_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_XOR);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_xor_expr_no_in' */
%type bit_xor_expr_no_in { Expression * }
%destructor bit_xor_expr_no_in { delete $$; }

bit_xor_expr_no_in(B) ::= bit_and_expr_no_in(A).
{
    B = A;
}

bit_xor_expr_no_in(C) ::= bit_xor_expr_no_in(B) BITWISE_XOR(D) bit_and_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_XOR);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_or_expr' */
%type bit_or_expr { Expression * }
%destructor bit_or_expr { delete $$; }

bit_or_expr(B) ::= bit_xor_expr(A).
{
    B = A;
}

bit_or_expr(C) ::= bit_or_expr(B) BITWISE_OR(D) bit_xor_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_OR);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_or_expr_no_fn' */
%type bit_or_expr_no_fn { Expression * }
%destructor bit_or_expr_no_fn { delete $$; }

bit_or_expr_no_fn(B) ::= bit_xor_expr_no_fn(A).
{
    B = A;
}

bit_or_expr_no_fn(C) ::= bit_or_expr_no_fn(B) BITWISE_OR(D) bit_xor_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_OR);
    C->element(B, A);

    delete D;
}

/* Rule 'bit_or_expr_no_in' */
%type bit_or_expr_no_in { Expression * }
%destructor bit_or_expr_no_in { delete $$; }

bit_or_expr_no_in(B) ::= bit_xor_expr_no_in(A).
{
    B = A;
}

bit_or_expr_no_in(C) ::= bit_or_expr_no_in(B) BITWISE_OR(D) bit_xor_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::BIT_OR);
    C->element(B, A);

    delete D;
}

/* Rule 'logic_and_expr' */
%type logic_and_expr { Expression * }
%destructor logic_and_expr { delete $$; }

logic_and_expr(B) ::= bit_or_expr(A).
{
    B = A;
}

logic_and_expr(C) ::= logic_and_expr(B) LOGIC_AND(D) bit_or_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LOGIC_AND);
    C->element(B, A);

    delete D;
}

/* Rule 'logic_and_expr_no_fn' */
%type logic_and_expr_no_fn { Expression * }
%destructor logic_and_expr_no_fn { delete $$; }

logic_and_expr_no_fn(B) ::= bit_or_expr_no_fn(A).
{
    B = A;
}

logic_and_expr_no_fn(C) ::= logic_and_expr_no_fn(B) LOGIC_AND(D) bit_or_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LOGIC_AND);
    C->element(B, A);

    delete D;
}

/* Rule 'logic_and_expr_no_in' */
%type logic_and_expr_no_in { Expression * }
%destructor logic_and_expr_no_in { delete $$; }

logic_and_expr_no_in(B) ::= bit_or_expr_no_in(A).
{
    B = A;
}

logic_and_expr_no_in(C) ::= logic_and_expr_no_in(B) LOGIC_AND(D) bit_or_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LOGIC_AND);
    C->element(B, A);

    delete D;
}

/* Rule 'logic_or_expr' */
%type logic_or_expr { Expression * }
%destructor logic_or_expr { delete $$; }

logic_or_expr(B) ::= logic_and_expr(A).
{
    B = A;
}

logic_or_expr(C) ::= logic_or_expr(B) LOGIC_OR(D) logic_and_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LOGIC_OR);
    C->element(B, A);

    delete D;
}

/* Rule 'logic_or_expr_no_fn' */
%type logic_or_expr_no_fn { Expression * }
%destructor logic_or_expr_no_fn { delete $$; }

logic_or_expr_no_fn(B) ::= logic_and_expr_no_fn(A).
{
    B = A;
}

logic_or_expr_no_fn(C) ::= logic_or_expr_no_fn(B) LOGIC_OR(D) logic_and_expr(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LOGIC_OR);
    C->element(B, A);

    delete D;
}

/* Rule 'logic_or_expr_no_in' */
%type logic_or_expr_no_in { Expression * }
%destructor logic_or_expr_no_in { delete $$; }

logic_or_expr_no_in(B) ::= logic_and_expr_no_in(A).
{
    B = A;
}

logic_or_expr_no_in(C) ::= logic_or_expr_no_in(B) LOGIC_OR(D) logic_and_expr_no_in(A).
{
    C = new expr::Binary(B, A, expr::Binary::OpType::LOGIC_OR);
    C->element(B, A);

    delete D;
}

/* Rule 'cond_expr' */
%type cond_expr { Expression * }
%destructor cond_expr { delete $$; }

cond_expr(B) ::= logic_or_expr(A).
{
    B = A;
}

cond_expr(D) ::= logic_or_expr(C) QUESTION(E) assign_expr(B) COLON(F) assign_expr(A).
{
    D = new expr::Condition(C, B, A);
    D->element(C, A);

    delete E;
    delete F;
}

/* Rule 'cond_expr_no_fn' */
%type cond_expr_no_fn { Expression * }
%destructor cond_expr_no_fn { delete $$; }

cond_expr_no_fn(B) ::= logic_or_expr_no_fn(A).
{
    B = A;
}

cond_expr_no_fn(D) ::= logic_or_expr_no_fn(C) QUESTION(E) assign_expr(B) COLON(F) assign_expr(A).
{
    D = new expr::Condition(C, B, A);
    D->element(C, A);

    delete E;
    delete F;
}

/* Rule 'cond_expr_no_in' */
%type cond_expr_no_in { Expression * }
%destructor cond_expr_no_in { delete $$; }

cond_expr_no_in(B) ::= logic_or_expr_no_in(A).
{
    B = A;
}

cond_expr_no_in(D) ::= logic_or_expr_no_in(C) QUESTION(E) assign_expr(B) COLON(F) assign_expr_no_in(A).
{
    D = new expr::Condition(C, B, A);
    D->element(C, A);

    delete E;
    delete F;
}

/* Rule 'assign_expr' */
%type assign_expr { Expression * }
%destructor assign_expr { delete $$; }

assign_expr(B) ::= cond_expr(A).
{
    B = A;
}

assign_expr(D) ::= left_hand_expr(C) assign_op(B) assign_expr(A).
{
    D = new expr::Assign(C, A, B);
    D->element(C, A);
}

/* Rule 'assign_expr_no_fn' */
%type assign_expr_no_fn { Expression * }
%destructor assign_expr_no_fn { delete $$; }

assign_expr_no_fn(B) ::= cond_expr_no_fn(A).
{
    B = A;
}

assign_expr_no_fn(D) ::= left_hand_expr_no_fn(C) assign_op(B) assign_expr(A).
{
    D = new expr::Assign(C, A, B);
    D->element(C, A);
}

/* Rule 'assign_expr_no_in' */
%type assign_expr_no_in { Expression * }
%destructor assign_expr_no_in { delete $$; }

assign_expr_no_in(B) ::= cond_expr_no_in(A).
{
    B = A;
}

assign_expr_no_in(D) ::= left_hand_expr(C) assign_op(B) assign_expr_no_in(A).
{
    D = new expr::Assign(C, A, B);
    D->element(C, A);
}

/* Rule 'assign_op' */
%type assign_op { expr::Assign::OpType }

assign_op(A) ::= ASSIGN(B).
{
    A = expr::Assign::OpType::SIMPLE;

    delete B;
}

assign_op(A) ::= MUL_ASSIGN(B).
{
    A = expr::Assign::OpType::MUL;

    delete B;
}

assign_op(A) ::= DIV_ASSIGN(B).
{
    A = expr::Assign::OpType::DIV;

    delete B;
}

assign_op(A) ::= MOD_ASSIGN(B).
{
    A = expr::Assign::OpType::MOD;

    delete B;
}

assign_op(A) ::= PLUS_ASSIGN(B).
{
    A = expr::Assign::OpType::PLUS;

    delete B;
}

assign_op(A) ::= MINUS_ASSIGN(B).
{
    A = expr::Assign::OpType::MINUS;

    delete B;
}

assign_op(A) ::= LEFT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::LEFT_SHIFT;

    delete B;
}

assign_op(A) ::= RIGHT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::RIGHT_SHIFT;

    delete B;
}

assign_op(A) ::= ZERO_RIGHT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::ZERO_RIGHT_SHIFT;

    delete B;
}

assign_op(A) ::= BITWISE_AND_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_AND;

    delete B;
}

assign_op(A) ::= BITWISE_XOR_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_XOR;

    delete B;
}

assign_op(A) ::= BITWISE_OR_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_OR;

    delete B;
}

/* Rule 'expr' */
%type expr { expr::Expressions * }
%destructor expr { delete $$; }

expr(B) ::= assign_expr(A).
{
    B = new expr::Expressions();
    B->items().push_back(std::unique_ptr<Expression>(A));
}

expr(C) ::= expr(B) COMMA(D) assign_expr(A).
{
    C = B;
    C->items().push_back(std::unique_ptr<Expression>(A));

    delete D;
}

/* Rule 'expr_no_fn' */
%type expr_no_fn { expr::Expressions * }
%destructor expr_no_fn { delete $$; }

expr_no_fn(B) ::= assign_expr_no_fn(A).
{
    B = new expr::Expressions();
    B->items().push_back(std::unique_ptr<Expression>(A));
}

expr_no_fn(C) ::= expr_no_fn(B) COMMA(D) assign_expr(A).
{
    C = B;
    C->items().push_back(std::unique_ptr<Expression>(A));

    delete D;
}

/* Rule 'expr_no_in' */
%type expr_no_in { expr::Expressions * }
%destructor expr_no_in { delete $$; }

expr_no_in(B) ::= assign_expr_no_in(A).
{
    B = new expr::Expressions();
    B->items().push_back(std::unique_ptr<Expression>(A));
}

expr_no_in(C) ::= expr_no_in(B) COMMA(D) assign_expr_no_in(A).
{
    C = B;
    C->items().push_back(std::unique_ptr<Expression>(A));

    delete D;
}

/* Rule 'literal' */
%type literal { Expression * }
%destructor literal { delete $$; }

literal(B) ::= LIT_NULL(A).
{
    B = new expr::literal::Null();
    B->element(A);

    delete A;
}

literal(B) ::= LIT_TRUE(A).
{
    B = new expr::literal::Boolean(true);
    B->element(A);

    delete A;
}

literal(B) ::= LIT_FALSE(A).
{
    B = new expr::literal::Boolean(false);
    B->element(A);

    delete A;
}

literal(B) ::= NUMBER(A).
{
    B = new expr::literal::Number(A->text());
    B->element(A);

    delete A;
}

literal(B) ::= STRING(A).
{
    const std::string content = A->text().substr(1, A->text().length() - 2);

    B = new expr::literal::String(content);
    B->element(A);

    delete A;
}

literal(B) ::= REGEXP(A).
{
    B = new expr::literal::Regexp(A->text());
    B->element(A);

    delete A;
}

/* Rule 'array' */
%type array { expr::Array * }
%destructor array { delete $$; }

array(A) ::= LBRACKET(B) RBRACKET(C).
{
    A = new expr::Array();

    delete B;
    delete C;
}

array(B) ::= LBRACKET(C) array_elision(A) RBRACKET(D).
{
    B = new expr::Array();

    for (auto it = A->begin(); it != A->end(); ++it)
    {
        B->elements().push_back(std::move(*it));
    }

    delete C;
    delete A;
    delete D;
}

array(B) ::= LBRACKET(C) array_element_list(A) RBRACKET(D).
{
    B = new expr::Array();

    for (auto it = A->begin(); it != A->end(); ++it)
    {
        B->elements().push_back(std::move(*it));
    }

    delete C;
    delete A;
    delete D;
}

array(B) ::= LBRACKET(C) array_element_list(A) COMMA(D) RBRACKET(E).
{
    B = new expr::Array();

    for (auto it = A->begin(); it != A->end(); ++it)
    {
        B->elements().push_back(std::move(*it));
    }

    delete C;
    delete A;
    delete D;
    delete E;
}

array(C) ::= LBRACKET(D) array_element_list(B) COMMA(E) array_elision(A) RBRACKET(F).
{
    C = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        C->elements().push_back(std::move(*it));
    }

    for (auto it = A->begin(); it != A->end(); ++it)
    {
        C->elements().push_back(std::move(*it));
    }

    delete D;
    delete B;
    delete E;
    delete A;
    delete F;
}

/* Rule 'array_elision' */
%type array_elision { std::vector<std::unique_ptr<Expression>> * }
%destructor array_elision { delete $$; }

array_elision(A) ::= COMMA(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(nullptr);

    delete B;
}

array_elision(B) ::= array_elision(A) COMMA(C).
{
    B = A;
    B->push_back(nullptr);

    delete C;
}

/* Rule 'array_element_list' */
%type array_element_list { std::vector<std::unique_ptr<Expression>> * }
%destructor array_element_list { delete $$; }

array_element_list(B) ::= assign_expr(A).
{
    B = new std::vector<std::unique_ptr<Expression>>();
    B->push_back(std::unique_ptr<Expression>(A));
}

array_element_list(C) ::= array_elision(B) assign_expr(A).
{
    C = B;
    C->push_back(std::unique_ptr<Expression>(A));
}

array_element_list(C) ::= array_element_list(B) COMMA(D) assign_expr(A).
{
    C = B;
    C->push_back(std::unique_ptr<Expression>(A));

    delete D;
}

array_element_list(D) ::= array_element_list(C) COMMA(E) array_elision(B) assign_expr(A).
{
    D = C;

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->push_back(std::move(*it));
    }

    D->push_back(std::unique_ptr<Expression>(A));

    delete E;
    delete B;
}

/* Rule 'object' */
%type object { expr::Object * }
%destructor object { delete $$; }

object(A) ::= LBRACE(B) RBRACE(C).
{
    A = new expr::Object();

    delete B;
    delete C;
}

object(D) ::= LBRACE(C) object_properties(B) RBRACE(A).
{
    D = new expr::Object();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->properties().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

object(D) ::= LBRACE(C) object_properties(B) COMMA(E) RBRACE(A).
{
    D = new expr::Object();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->properties().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete B;
    delete E;
    delete A;
}

/* Rule 'object_properties' */
%type object_properties { std::vector<std::unique_ptr<expr::object::Property>> * }
%destructor object_properties { delete $$; }

object_properties(B) ::= object_property(A).
{
    B = new std::vector<std::unique_ptr<expr::object::Property>>();
    B->push_back(std::unique_ptr<expr::object::Property>(A));
}

object_properties(C) ::= object_properties(B) COMMA(D) object_property(A).
{
    C = B;
    C->push_back(std::unique_ptr<expr::object::Property>(A));

    delete D;
}

/* Rule 'object_property' */
%type object_property { expr::object::Property * }
%destructor object_property { delete $$; }

object_property(C) ::= object_property_name(B) COLON(D) assign_expr(A).
{
    C = new expr::object::Property();
    C->key(B);
    C->value(A);
    C->element(B, A);

    delete D;
}

object_property ::= GET(A) object_property_name LPAREN(B) RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

object_property ::= SET(A) object_property_name LPAREN(B) object_property_set_params RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

/* Rule 'object_property_name' */
%type object_property_name { Expression * }
%destructor object_property_name { delete $$; }

object_property_name(B) ::= ident(A).
{
    B = A;
}

object_property_name(B) ::= STRING(A).
{
    B = new expr::literal::String(A->text());
    B->element(A);

    delete A;
}

object_property_name(B) ::= NUMBER(A).
{
    B = new expr::literal::Number(A->text());
    B->element(A);

    delete A;
}

/* Rule 'object_property_set_params' */
%type object_property_set_params { std::vector<std::string> * }
%destructor object_property_set_params { delete $$; }

object_property_set_params(B) ::= ident(A).
{
    B = new std::vector<std::string>();
    B->push_back(A->name());

    delete A;
}

/* Rule 'arguments' */
%type arguments { args::Arguments * }
%destructor arguments { delete $$; }

arguments(C) ::= LPAREN(B) RPAREN(A).
{
    C = new args::Arguments();
    C->element(B, A);

    delete B;
    delete A;
}

arguments(D) ::= LPAREN(C) arguments_list(B) RPAREN(A).
{
    D = new args::Arguments();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        D->elements().push_back(std::move(*it));
    }

    D->element(C, A);

    delete C;
    delete B;
    delete A;
}

/* Rule 'arguments_list' */
%type arguments_list { std::vector<std::unique_ptr<Expression>> * }
%destructor arguments_list { delete $$; }

arguments_list(B) ::= assign_expr(A).
{
    B = new std::vector<std::unique_ptr<Expression>>();
    B->push_back(std::unique_ptr<Expression>(A));
}

arguments_list(C) ::= arguments_list(B) COMMA(D) assign_expr(A).
{
    C = B;
    C->push_back(std::unique_ptr<Expression>(A));

    delete D;
}

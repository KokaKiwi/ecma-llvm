%token_prefix       ECMA_LEXEME_TYPE_
%token_type         { lex::Lexeme * }
%extra_argument     { parser::Parser *parser }
%name               EcmaParse
%start_symbol       program

%include {
    #include <cassert>
    #include <cstdio>
    #include <vector>
    #include <string>
    #include "ecma/lex/lexeme.h"
    #include "ecma/parser/parser.h"

    #include "ecma/ast/node.h"
    #include "ecma/ast/expression.h"
    #include "ecma/ast/statement.h"
    #include "ecma/ast/stmt/block.h"
    #include "ecma/ast/stmt/decl/variables.h"

    using namespace ecma;
}

%syntax_error {
    int n = sizeof(yyTokenName) / sizeof(*yyTokenName);
    for (int i = 0; i < n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            parser->errors().push_back(yyTokenName[i]);
        }
    }
    parser->error(true);
}

%left Do If In For New Try Var Case Else Null This True With Break Catch False While.
%left Return Switch TypeOf Default Finally Continue Function Undefined InstanceOf.

%left Plus Minus Mul Div Mod.

%left Assign PlusAssign MinusAssign MulAssign DivAssign ModAssign.

%left RightShiftAssign BinaryAndAssign BinaryOrAssign XorAssign.

%left Greater GreaterOrEqual Lesser LesserOrEqual Equal NotEqual Identity NotIdentity.

%left Not Inv Incrementation Decrementation.

%left LogicalOr LogicalAnd BitwiseOr BitwiseAnd BitwiseXor.

%left LeftShift RightShift.

%left LParen LBracket LBrace.
%left RParen RBracket RBrace.

%left QuestionMark Dot.

%left Semicolon Colon Comma.

%left Identifier Integer Double String.

/* Level 0 */

program ::= source_elements(A). { parser->program(A); }

/* Level 1 */

%type source_elements { ast::stmt::Block * }
source_elements(A) ::= . { A = new ast::stmt::Block(); }
source_elements(A) ::= source_elements(B) source_element(C). { B->statements().push_back(C); A = B; }

/* Level 2 */

%type source_element { ast::Statement * }
source_element(A) ::= function_declaration(B). { A = B; }
source_element(A) ::= statement(B). { A = B; }

/* Level 3 */

%type function_declaration { ast::Statement * }
function_declaration ::= Function Identifier LParen RParen LBrace source_elements RBrace.
function_declaration ::= Function Identifier LParen function_params RParen LBrace source_elements RBrace.

%type statement { ast::Statement * }
statement(A) ::= block(B). { A = B; }
statement(A) ::= varstatement(B). { A = B; }
statement(A) ::= emptystatement. { A = nullptr; }
statement(A) ::= exprstatement. { A = nullptr; }
statement(A) ::= ifstatement. { A = nullptr; }
statement(A) ::= iterstatement. { A = nullptr; }
statement(A) ::= contstatement. { A = nullptr; }
statement(A) ::= breakstatement. { A = nullptr; }
statement(A) ::= returnstatement. { A = nullptr; }
statement(A) ::= withstatement. { A = nullptr; }
statement(A) ::= labelstatement. { A = nullptr; }
statement(A) ::= switchstatement. { A = nullptr; }
statement(A) ::= throwstatement. { A = nullptr; }
statement(A) ::= trystatement. { A = nullptr; }

/* Level 4 */

%type block { ast::stmt::Block * }
block(A) ::= LBrace statements(B) RBrace. { A = B; }

%type varstatement { ast::stmt::decl::Variables * }
varstatement(A) ::= Var vardecls(B) Semicolon. { A = B; }

emptystatement ::= Semicolon.

exprstatement ::= top_expression Semicolon.

function_params ::= Identifier.
function_params ::= function_params Comma Identifier.

ifstatement ::= If LParen expression RParen statement Else statement.
ifstatement ::= If LParen expression RParen statement.

iterstatement ::= Do statement While LParen expression RParen.
iterstatement ::= While LParen expression RParen statement.
iterstatement ::= For LParen expressionsNoIn Semicolon expressions Semicolon expressions RParen statement.
iterstatement ::= For LParen Var vardeclsNoIn Semicolon expressions Semicolon expressions RParen statement.
iterstatement ::= For LParen leftexpression In expression RParen statement.
iterstatement ::= For LParen Var vardeclNoIn In expression RParen statement.

    expressionsNoIn ::= expressionNoIn.
    expressionsNoIn ::= .

    expressions ::= expression.
    expressions ::= .

contstatement ::= Continue Semicolon.
contstatement ::= Continue Identifier Semicolon.

breakstatement ::= Break Semicolon.
breakstatement ::= Break Identifier Semicolon.

returnstatement ::= Return Semicolon.
returnstatement ::= Return expression Semicolon.

withstatement ::= With LParen expression RParen statement.

labelstatement ::= Identifier Colon statement.

switchstatement ::= Switch LParen expression RParen caseblock.

throwstatement ::= Throw expression Semicolon.

trystatement ::= Try block catch.
trystatement ::= Try block finally.
trystatement ::= Try block catch finally.

/* Level 5 */

caseblock ::= LBrace RBrace.
caseblock ::= LBrace caseclauses RBrace.

catch ::= Catch LParen Identifier RParen block.

expression ::= assignexpression.
expression ::= functionexpression.
expression ::= expression Comma assignexpression.

top_expression ::= assignexpression.
top_expression ::= top_expression Comma assignexpression.

expressionNoIn ::= assignexpressionNoIn.
expressionNoIn ::= expressionNoIn Comma assignexpressionNoIn.

finally ::= Finally block.

leftexpression ::= newexpression.
leftexpression ::= callexpression.

%type statements { ast::stmt::Block * }
statements(A) ::= statement(B). { A = new ast::stmt::Block(); A->statements().push_back(B); }
statements(A) ::= statements(B) statement(C). { B->statements().push_back(C); A = B; }

%type vardecls { ast::stmt::decl::Variables * }
vardecls(A) ::= vardecl(B). { A = new ast::stmt::decl::Variables(); A->vars().push_back(B); }
vardecls(A) ::= vardecls(B) Comma vardecl(C). { B->vars().push_back(C); A = B; }

vardeclsNoIn ::= vardeclNoIn.
vardeclsNoIn ::= vardeclsNoIn Comma vardeclNoIn.

vardeclNoIn ::= Identifier.
vardeclNoIn ::= Identifier Assign assignexpressionNoIn.

/* Level 6 */

assignexpression ::= condexpression.
assignexpression ::= leftexpression assignop down_expression.

assignexpressionNoIn ::= condexpressionNoIn.
assignexpressionNoIn ::= leftexpression assignop down_expressionNoIn.

callexpression ::= memberexpression arguments.
callexpression ::= callexpression arguments.
callexpression ::= callexpression LBracket expression RBracket.
callexpression ::= callexpression Dot Identifier.

caseclauses ::= caseclause.
caseclauses ::= caseclauses caseclause.

newexpression ::= memberexpression.
newexpression ::= New newexpression.

%type vardecl { ast::stmt::decl::Variables::Variable * }
vardecl(A) ::= Identifier(B). { A = new ast::stmt::decl::Variables::Variable(*B); }
vardecl(A) ::= Identifier(B) Assign down_expression(C). { A = new ast::stmt::decl::Variables::Variable(*B, C); }

/* Level 7 */

arguments ::= LParen RParen.
arguments ::= LParen arguments_list RParen.

assignop ::= Assign.
assignop ::= PlusAssign.
assignop ::= MinusAssign.
assignop ::= MulAssign.
assignop ::= DivAssign.
assignop ::= ModAssign.
assignop ::= RightShiftAssign.
assignop ::= BinaryAndAssign.
assignop ::= BinaryOrAssign.
assignop ::= XorAssign.

caseclause ::= Case expression Colon.
caseclause ::= Case expression Colon statements.
caseclause ::= Default Colon.
caseclause ::= Default Colon statements.

condexpression ::= logical_or_expr.
condexpression ::= logical_or_expr QuestionMark assignexpression Colon assignexpression.

condexpressionNoIn ::= logical_or_exprNoIn.
condexpressionNoIn ::= logical_or_exprNoIn QuestionMark assignexpressionNoIn Colon assignexpressionNoIn.

%type down_expression { ast::Expression * }
down_expression ::= assignexpression.
down_expression ::= functionexpression.

down_expressionNoIn ::= assignexpressionNoIn.
down_expressionNoIn ::= functionexpression.

memberexpression ::= primaryexpression.
memberexpression ::= memberexpression LBracket expression RBracket.
memberexpression ::= memberexpression Dot Identifier.
memberexpression ::= New memberexpression arguments.

/* Level 8 */

arguments_list ::= down_expression.
arguments_list ::= arguments_list Comma down_expression.

functionexpression ::= Function func_name LParen RParen LBrace source_elements RBrace.
functionexpression ::= Function func_name LParen function_params RParen LBrace source_elements RBrace.

    func_name ::= .
    func_name ::= Identifier.

logical_or_expr ::= logical_and_expr.
logical_or_expr ::= logical_or_expr LogicalOr logical_and_expr.

logical_or_exprNoIn ::= logical_and_exprNoIn.
logical_or_exprNoIn ::= logical_or_exprNoIn LogicalOr logical_and_exprNoIn.

primaryexpression ::= This.
primaryexpression ::= Identifier.
primaryexpression ::= literal.
primaryexpression ::= arrayliteral.
primaryexpression ::= objectliteral.
primaryexpression ::= LParen down_expression RParen.

/* Level 9 */

arrayliteral ::= LBracket RBracket.
arrayliteral ::= LBracket elision RBracket.
arrayliteral ::= LBracket element_list RBracket.
arrayliteral ::= LBracket element_list Comma RBracket.
arrayliteral ::= LBracket element_list Comma elision RBracket.

literal ::= Null.
literal ::= True.
literal ::= False.
literal ::= Integer.
literal ::= Double.
literal ::= String.

logical_and_expr ::= bitwise_or_expr.
logical_and_expr ::= logical_and_expr LogicalAnd bitwise_or_expr.

logical_and_exprNoIn ::= bitwise_or_exprNoIn.
logical_and_exprNoIn ::= logical_and_exprNoIn LogicalAnd bitwise_or_exprNoIn.

objectliteral ::= LBrace RBrace.
objectliteral ::= LBrace object_properties RBrace.

/* Level 10 */

bitwise_or_expr ::= bitwise_xor_expr.
bitwise_or_expr ::= bitwise_or_expr BitwiseOr bitwise_xor_expr.

bitwise_or_exprNoIn ::= bitwise_xor_exprNoIn.
bitwise_or_exprNoIn ::= bitwise_or_exprNoIn BitwiseOr bitwise_xor_exprNoIn.

element_list ::= down_expression.
element_list ::= elision down_expression.
element_list ::= element_list Comma down_expression.
element_list ::= element_list Comma elision down_expression.

elision ::= Comma.
elision ::= elision Comma.

object_properties ::= property_name Colon down_expression.
object_properties ::= object_properties Comma property_name Colon down_expression.

/* Level 11 */

bitwise_xor_expr ::= bitwise_and_expr.
bitwise_xor_expr ::= bitwise_xor_expr BitwiseXor bitwise_and_expr.

bitwise_xor_exprNoIn ::= bitwise_and_exprNoIn.
bitwise_xor_exprNoIn ::= bitwise_xor_exprNoIn BitwiseXor bitwise_and_exprNoIn.

property_name ::= Identifier.
property_name ::= String.
property_name ::= Number.

/* Level 12 */

bitwise_and_expr ::= equality_expr.
bitwise_and_expr ::= bitwise_and_expr BitwiseAnd equality_expr.

bitwise_and_exprNoIn ::= equality_exprNoIn.
bitwise_and_exprNoIn ::= bitwise_and_exprNoIn BitwiseAnd equality_exprNoIn.

/* Level 13 */

equality_expr ::= relational_expr.
equality_expr ::= equality_expr Equal relational_expr.
equality_expr ::= equality_expr NotEqual relational_expr.
equality_expr ::= equality_expr Identity relational_expr.
equality_expr ::= equality_expr NotIdentity relational_expr.

equality_exprNoIn ::= relational_exprNoIn.
equality_exprNoIn ::= equality_exprNoIn Equal relational_exprNoIn.
equality_exprNoIn ::= equality_exprNoIn NotEqual relational_exprNoIn.

/* Level 14 */
relational_expr ::= shift_expr.
relational_expr ::= relational_expr Lesser shift_expr.
relational_expr ::= relational_expr LesserOrEqual shift_expr.
relational_expr ::= relational_expr Greater shift_expr.
relational_expr ::= relational_expr GreaterOrEqual shift_expr.
relational_expr ::= relational_expr InstanceOf shift_expr.
relational_expr ::= relational_expr In shift_expr.

relational_exprNoIn ::= shift_expr.
relational_exprNoIn ::= relational_exprNoIn Lesser shift_expr.
relational_exprNoIn ::= relational_exprNoIn LesserOrEqual shift_expr.
relational_exprNoIn ::= relational_exprNoIn Greater shift_expr.
relational_exprNoIn ::= relational_exprNoIn GreaterOrEqual shift_expr.
relational_exprNoIn ::= relational_exprNoIn InstanceOf shift_expr.

/* Level 15 */

shift_expr ::= add_expr.
shift_expr ::= shift_expr LeftShift add_expr.
shift_expr ::= shift_expr RightShift add_expr.

/* Level 16 */

add_expr ::= mul_expr.
add_expr ::= add_expr Plus mul_expr.
add_expr ::= add_expr Minus mul_expr.

/* Level 17 */

mul_expr ::= unary_expr.
mul_expr ::= mul_expr Mul unary_expr.
mul_expr ::= mul_expr Div unary_expr.
mul_expr ::= mul_expr Mod unary_expr.

/* Level 18 */

unary_expr ::= postfix_expr.
unary_expr ::= Not unary_expr.
unary_expr ::= Inv unary_expr.
unary_expr ::= Incrementation unary_expr.
unary_expr ::= Decrementation unary_expr.
unary_expr ::= TypeOf unary_expr.

/* Level 19 */

postfix_expr ::= leftexpression.
postfix_expr ::= leftexpression Incrementation.
postfix_expr ::= leftexpression Decrementation.

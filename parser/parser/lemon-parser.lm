%token_prefix       ECMA_TOKEN_TYPE_
%token_type         { lex::Token * }
%extra_argument     { parser::Parser *parser }
%name               ecma_parse

%include
{
    #include <cassert>
    #include <cstdio>
    #include <memory>
    #include <vector>
    #include <string>
    #include "ecma/lex/token.h"
    #include "ecma/parser/parser.h"
    #include "ecma/parser/exception.h"

    #include "ecma/ast/ast.h"

    using namespace ecma;
    using namespace ecma::ast;
}

%syntax_error {
    std::vector<std::string> expected;

    int n = sizeof(yyTokenName) / sizeof(*yyTokenName);
    for (int i = 0; i < n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            expected.push_back(yyTokenName[i]);
        }
    }
    throw parser::UnexpectedToken(TOKEN, expected);
}

%left REGEXP STRING NUMBER IDENT.
%left INSTANCEOF CONTINUE DEBUGGER FUNCTION DEFAULT FINALLY DELETE RETURN SWITCH TYPEOF BREAK CATCH THROW WHILE CASE THIS VOID WITH FOR GET NEW SET TRY VAR DO IN.
%right ELSE IF.
%left EXTENDS EXPORT IMPORT CLASS CONST SUPER ENUM.
%left IMPLEMENTS INTERFACE PROTECTED PACKAGE PRIVATE PUBLIC STATIC YIELD LET.
%left ZERO_RIGHT_SHIFT_ASSIGN STRICT_EQUAL STRICT_NOT_EQUAL ZERO_RIGHT_SHIFT LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN LESSER_EQ GREATER_EQ EQUAL NOT_EQUAL INCREMENT DECREMENT LEFT_SHIFT RIGHT_SHIFT LOGIC_AND LOGIC_OR PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET DOT SEMICOLON COMMA QUESTION COLON LESSER GREATER PLUS MINUS MUL MOD DIV BITWISE_AND BITWISE_OR BITWISE_XOR ASSIGN NOT INV.
%left LIT_UNDEFINED LIT_FALSE LIT_NULL LIT_TRUE.

/* Rule 'module' */
%start_symbol module

module ::= .
{
}

module ::= source_elements.
{
}

/* Rule 'function_decl' */

function_decl ::= FUNCTION(A) IDENT(B) LPAREN(C) RPAREN(D) LBRACE(E) function_body RBRACE(F).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
    delete F;
}

function_decl ::= FUNCTION(A) IDENT(B) LPAREN(C) formal_params RPAREN(D) LBRACE(E) function_body RBRACE(F).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
    delete F;
}

/* Rule 'function_expr' */

function_expr ::= FUNCTION(A) IDENT(B) LPAREN(C) RPAREN(D) LBRACE(E) function_body RBRACE(F).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
    delete F;
}

function_expr ::= FUNCTION(A) IDENT(B) LPAREN(C) formal_params RPAREN(D) LBRACE(E) function_body RBRACE(F).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
    delete F;
}

function_expr ::= FUNCTION(A) LPAREN(B) RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

function_expr ::= FUNCTION(A) LPAREN(B) formal_params RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

/* Rule 'formal_params' */

formal_params ::= IDENT(A).
{
    delete A;
}

formal_params ::= formal_params COMMA(A) IDENT(B).
{
    delete A;
    delete B;
}

/* Rule 'function_body' */

function_body ::= .
{
}

function_body ::= source_elements.
{
}

/* Rule 'source_elements' */

source_elements ::= source_element.
{
}

source_elements ::= source_elements source_element.
{
}

/* Rule 'source_element' */
%type source_element { Statement * }

source_element(A) ::= stmt(B).
{
    A = B;
}

source_element(A) ::= function_decl(B).
{
    // A = B;
}

/* Rule 'stmt' */
%type stmt { Statement * }

stmt(A) ::= block(B).
{
    A = B;
}

stmt(A) ::= var_stmt(B).
{
    A = B;
}

stmt(A) ::= empty_stmt.
{
    A = nullptr;
}

stmt(A) ::= expr_stmt(B).
{
    A = B;
}

stmt(A) ::= if_stmt(B).
{
    A = B;
}

stmt(A) ::= iter_stmt(B).
{
    A = B;
}

stmt(A) ::= cont_stmt(B).
{
    A = B;
}

stmt(A) ::= break_stmt(B).
{
    A = B;
}

stmt(A) ::= return_stmt(B).
{
    A = B;
}

stmt(A) ::= with_stmt(B).
{
    A = B;
}

stmt(A) ::= switch_stmt(B).
{
    A = B;
}

stmt(A) ::= throw_stmt(B).
{
    A = B;
}

stmt(A) ::= try_stmt(B).
{
    A = B;
}

stmt(A) ::= debug_stmt(B).
{
    A = B;
}

/* Rule 'block' */
%type block { stmt::Block * }

block(A) ::= LBRACE(B) stmt_list(C) RBRACE(D).
{
    A = new stmt::Block();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->statements().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'block_empty' */
%type block_empty { stmt::Block * }

block_empty(A) ::= LBRACE(B) RBRACE(C).
{
    A = new stmt::Block();
    A->element(B, C);

    delete B;
    delete C;
}

/* Rule 'block_stmt' */
%type block_stmt { stmt::Block * }

block_stmt(A) ::= block(B).
{
    A = B;
}

block_stmt(A) ::= block_empty(B).
{
    A = B;
}

/* Rule 'stmt_list' */
%type stmt_list { std::vector<std::unique_ptr<Statement>> * }

stmt_list(A) ::= stmt(B).
{
    A = new std::vector<std::unique_ptr<Statement>>();
    A->push_back(std::unique_ptr<Statement>(B));
}

stmt_list(A) ::= stmt_list(B) stmt(C).
{
    A = B;
    A->push_back(std::unique_ptr<Statement>(C));
}

/* Rule 'var_stmt' */
%type var_stmt { stmt::decl::Vars * }

var_stmt(A) ::= VAR(B) var_decls(C) SEMICOLON(D).
{
    A = new stmt::decl::Vars();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->decls().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'var_decls' */
%type var_decls { std::vector<std::unique_ptr<stmt::decl::Var>> * }

var_decls(A) ::= var_decl(B).
{
    A = new std::vector<std::unique_ptr<stmt::decl::Var>>();
    A->push_back(std::unique_ptr<stmt::decl::Var>(B));
}

var_decls(A) ::= var_decls(B) COMMA(D) var_decl(C).
{
    A = B;
    A->push_back(std::unique_ptr<stmt::decl::Var>(C));

    delete D;
}

/* Rule 'var_decls_no_in' */
%type var_decls_no_in { std::vector<std::unique_ptr<stmt::decl::Var>> * }

var_decls_no_in(A) ::= var_decl_no_in(B).
{
    A = new std::vector<std::unique_ptr<stmt::decl::Var>>();
    A->push_back(std::unique_ptr<stmt::decl::Var>(B));
}

var_decls_no_in(A) ::= var_decls_no_in(B) COMMA(D) var_decl_no_in(C).
{
    A = B;
    A->push_back(std::unique_ptr<stmt::decl::Var>(C));

    delete D;
}

/* Rule 'var_decl' */
%type var_decl { stmt::decl::Var * }

var_decl(A) ::= IDENT(B).
{
    A = new stmt::decl::Var(B->text());
    A->element(B);

    delete B;
}

var_decl(A) ::= IDENT(B) init(C).
{
    A = new stmt::decl::Var(B->text());
    A->element(B, C);

    delete B;
}

/* Rule 'var_decl_no_in' */
%type var_decl_no_in { stmt::decl::Var * }

var_decl_no_in(A) ::= IDENT(B).
{
    A = new stmt::decl::Var(B->text());
    A->element(B);

    delete B;
}

var_decl_no_in(A) ::= IDENT(B) init_no_in(C).
{
    A = new stmt::decl::Var(B->text());
    A->element(B, C);

    delete B;
}

/* Rule 'init' */
%type init { Expression * }

init(A) ::= ASSIGN(C) assign_expr(B).
{
    A = B;

    delete C;
}

/* Rule 'init_no_in' */
%type init_no_in { Expression * }

init_no_in(A) ::= ASSIGN(C) assign_expr_no_in(B).
{
    A = B;

    delete C;
}

/* Rule 'empty_stmt' */

empty_stmt ::= SEMICOLON(A).
{
    delete A;
}

/* Rule 'expr_stmt' */
%type expr_stmt { stmt::ExpressionStmt * }

expr_stmt(A) ::= expr_no_fn(B) SEMICOLON(C).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B, C);

    delete C;
}

/* Rule 'if_stmt' */
%type if_stmt { stmt::If * }

if_stmt(A) ::= IF(B) LPAREN(E) expr(C) RPAREN(F) stmt(D).
{
    A = new stmt::If(C, D);
    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

if_stmt(A) ::= IF(B) LPAREN(F) expr(C) RPAREN(G) stmt(D) ELSE(H) stmt(E).
{
    A = new stmt::If(C, D);
    A->else_stmt(E);
    A->element(B, E);

    delete B;
    delete F;
    delete G;
    delete H;
}

/* Rule 'iter_stmt' */
%type iter_stmt { Statement * }

iter_stmt(A) ::= while_stmt(B).
{
    A = B;
}

iter_stmt(A) ::= for_stmt(B).
{
    A = B;
}

iter_stmt(A) ::= for_in_stmt(B).
{
    A = B;
}

/* Rule 'while_stmt' */
%type while_stmt { stmt::While * }

while_stmt(A) ::= WHILE(B) LPAREN(E) expr(C) RPAREN(F) stmt(D).
{
    A = new stmt::While(false, C, D);
    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

while_stmt(A) ::= DO(B) stmt(C) WHILE(F) LPAREN(G) expr(D) RPAREN(E).
{
    A = new stmt::While(true, D, C);
    A->element(B, E);

    delete B;
    delete F;
    delete G;
    delete E;
}

/* Rule 'for_stmt' */
%type for_stmt { stmt::For * }

for_stmt(A) ::= FOR(B) LPAREN(G) for_init(C) SEMICOLON(H) for_cond(D) SEMICOLON(I) for_loop(E) RPAREN(J) stmt(F).
{
    A = new stmt::For(C, D, E, F);
    A->element(B, F);

    delete B;
    delete G;
    delete H;
    delete I;
    delete J;
}

for_stmt ::= FOR(A) LPAREN(B) VAR(C) var_decls_no_in SEMICOLON(D) for_cond SEMICOLON(E) for_loop RPAREN(F) stmt.
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
    delete F;
}

/* Rule 'for_init' */
%type for_init { Statement * }

for_init(A) ::= .
{
    A = nullptr;
}

for_init(A) ::= expr_no_in(B).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B);
}

/* Rule 'for_cond' */
%type for_cond { Statement * }

for_cond(A) ::= .
{
    A = nullptr;
}

for_cond(A) ::= expr(B).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B);
}

/* Rule 'for_loop' */
%type for_loop { Statement * }

for_loop(A) ::= .
{
    A = nullptr;
}

for_loop(A) ::= expr(B).
{
    A = new stmt::ExpressionStmt(B);
    A->element(B);
}

/* Rule 'for_in_stmt' */
%type for_in_stmt { stmt::ForIn * }

for_in_stmt(A) ::= FOR(B) LPAREN(F) left_hand_expr(C) IN(G) expr(D) RPAREN(H) stmt(E).
{
    A = new stmt::ForIn(C, D, E);
    A->element(B, E);

    delete B;
    delete F;
    delete G;
    delete H;
}

for_in_stmt(A) ::= FOR(B) LPAREN(F) VAR(G) var_decl_no_in(C) IN(H) expr(D) RPAREN(I) stmt(E).
{
    auto counter = new expr::Ident(C->name());

    A = new stmt::ForIn(counter, D, E);
    A->init(C->init());
    A->element(B, E);

    delete C;

    delete B;
    delete F;
    delete G;
    delete H;
    delete I;
}

/* Rule 'cont_stmt' */
%type cont_stmt { stmt::Continue * }

cont_stmt(A) ::= CONTINUE(B) SEMICOLON(C).
{
    A = new stmt::Continue();
    A->element(B, C);

    delete B;
    delete C;
}

cont_stmt(A) ::= CONTINUE(B) IDENT(C) SEMICOLON(D).
{
    A = new stmt::Continue();
    A->name(new std::string(C->text()));
    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'break_stmt' */
%type break_stmt { stmt::Break * }

break_stmt(A) ::= BREAK(B) SEMICOLON(C).
{
    A = new stmt::Break();
    A->element(B, C);

    delete B;
    delete C;
}

break_stmt(A) ::= BREAK(B) IDENT(C) SEMICOLON(D).
{
    A = new stmt::Break();
    A->name(new std::string(C->text()));
    A->element(B, D);

    delete B;
    delete C;
    delete D;
}

/* Rule 'return_stmt' */
%type return_stmt { stmt::Return * }

return_stmt(A) ::= RETURN(B) SEMICOLON(C).
{
    A = new stmt::Return();
    A->element(B, C);

    delete B;
    delete C;
}

return_stmt(A) ::= RETURN(B) expr(C) SEMICOLON(D).
{
    A = new stmt::Return();
    A->expr(C);
    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'with_stmt' */
%type with_stmt { stmt::With * }

with_stmt(A) ::= WITH(B) LPAREN(E) expr(C) RPAREN(F) stmt(D).
{
    A = new stmt::With(C, D);
    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

/* Rule 'switch_stmt' */
%type switch_stmt { stmt::Switch * }

switch_stmt(A) ::= SWITCH(B) LPAREN(E) expr(C) RPAREN(F) case_block(D).
{
    A = new stmt::Switch(C);

    A->element(B, D);

    delete B;
    delete E;
    delete F;
}

/* Rule 'case_block' */

case_block ::= LBRACE(A) RBRACE(B).
{
    delete A;
    delete B;
}

case_block ::= LBRACE(A) case_clauses RBRACE(B).
{
    delete A;
    delete B;
}

/* Rule 'case_clauses' */

case_clauses ::= case_clause.
{
}

case_clauses ::= case_clauses case_clause.
{
}

/* Rule 'case_clause' */

case_clause ::= case_key COLON(A).
{
    delete A;
}

case_clause ::= case_key COLON(A) stmt_list.
{
    delete A;
}

/* Rule 'case_key' */

case_key ::= CASE(A) expr.
{
    delete A;
}

case_key ::= DEFAULT(A).
{
    delete A;
}

/* Rule 'throw_stmt' */
%type throw_stmt { stmt::Throw * }

throw_stmt(A) ::= THROW(B) expr(C) SEMICOLON(D).
{
    A = new stmt::Throw(C);
    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'try_stmt' */
%type try_stmt { Statement * }

try_stmt ::= TRY(A) block_stmt catch.
{
    delete A;
}

try_stmt ::= TRY(A) block_stmt finally.
{
    delete A;
}

try_stmt ::= TRY(A) block_stmt catch finally.
{
    delete A;
}

/* Rule 'catch' */

catch ::= CATCH(A) LPAREN(B) IDENT(C) RPAREN(D) block_stmt.
{
    delete A;
    delete B;
    delete C;
    delete D;
}

/* Rule 'finally' */

finally ::= FINALLY(A) block_stmt.
{
    delete A;
}

/* Rule 'debug_stmt' */
%type debug_stmt { stmt::Debug * }

debug_stmt(A) ::= DEBUGGER(B) SEMICOLON(C).
{
    A = new stmt::Debug();
    A->element(B, C);

    delete B;
    delete C;
}

/* Rule 'primary_expr' */
%type primary_expr { Expression * }

primary_expr(A) ::= THIS(B).
{
    A = new expr::This();
    A->element(B);

    delete B;
}

primary_expr(A) ::= IDENT(B).
{
    A = new expr::Ident(B->text());
    A->element(B);

    delete B;
}

primary_expr(A) ::= literal(B).
{
    A = B;
}

primary_expr(A) ::= array(B).
{
    A = B;
}

primary_expr(A) ::= object(B).
{
    A = B;
}

primary_expr(A) ::= LPAREN(C) expr(B) RPAREN(D).
{
    A = B;

    delete C;
    delete D;
}

/* Rule 'member_expr' */
%type member_expr { Expression * }

member_expr(A) ::= primary_expr(B).
{
    A = B;
}

member_expr ::= function_expr.
{
}

member_expr(A) ::= member_expr(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

member_expr(A) ::= member_expr(B) DOT(D) IDENT(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->text());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

member_expr(A) ::= NEW(B) member_expr(C) arguments(D).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    for(auto it = D->elements().begin(); it != D->elements().end(); ++it)
    {
        new_expr->args().push_back(std::move(*it));
    }

    A = new_expr;
    A->element(B, D);

    delete B;
}

/* Rule 'member_expr_no_fn' */
%type member_expr_no_fn { Expression * }

member_expr_no_fn(A) ::= primary_expr(B).
{
    A = B;
}

member_expr_no_fn(A) ::= member_expr_no_fn(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

member_expr_no_fn(A) ::= member_expr_no_fn(B) DOT(D) IDENT(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->text());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

member_expr_no_fn(A) ::= NEW(B) member_expr(C) arguments(D).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    for(auto it = D->elements().begin(); it != D->elements().end(); ++it)
    {
        new_expr->args().push_back(std::move(*it));
    }

    A = new_expr;
    A->element(B, D);

    delete B;
}

/* Rule 'new_expr' */
%type new_expr { Expression * }

new_expr(A) ::= member_expr(B).
{
    A = B;
}

new_expr(A) ::= NEW(B) new_expr(C).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    A = new_expr;
    A->element(B, C);

    delete B;
}

/* Rule 'new_expr_no_fn' */
%type new_expr_no_fn { Expression * }

new_expr_no_fn(A) ::= member_expr_no_fn(B).
{
    A = B;
}

new_expr_no_fn(A) ::= NEW(B) new_expr(C).
{
    auto new_expr = new expr::New();
    new_expr->expr(C);

    A = new_expr;
    A->element(B, C);

    delete B;
}

/* Rule 'call_expr' */
%type call_expr { Expression * }

call_expr(A) ::= member_expr(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);
}

call_expr(A) ::= call_expr(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);
}

call_expr(A) ::= call_expr(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

call_expr(A) ::= call_expr(B) DOT(D) IDENT(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->text());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

/* Rule 'call_expr_no_fn' */
%type call_expr_no_fn { Expression * }

call_expr_no_fn(A) ::= member_expr_no_fn(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);
}

call_expr_no_fn(A) ::= call_expr_no_fn(B) arguments(C).
{
    auto call = new expr::Call(B);

    for(auto it = C->elements().begin(); it != C->elements().end(); ++it)
    {
        call->args().push_back(std::move(*it));
    }

    A = call;
    A->element(B, C);
}

call_expr_no_fn(A) ::= call_expr_no_fn(B) LBRACKET(E) expr(C) RBRACKET(D).
{
    auto index = new expr::Index();
    index->expr(B);
    index->index(C);

    A = index;
    A->element(B, D);

    delete E;
    delete D;
}

call_expr_no_fn(A) ::= call_expr_no_fn(B) DOT(D) IDENT(C).
{
    auto member = new expr::Member();
    member->expr(B);
    member->name(C->text());

    A = member;
    A->element(B, C);

    delete D;
    delete C;
}

/* Rule 'left_hand_expr' */
%type left_hand_expr { Expression * }

left_hand_expr(A) ::= new_expr(B).
{
    A = B;
}

left_hand_expr(A) ::= call_expr(B).
{
    A = B;
}

/* Rule 'left_hand_expr_no_fn' */
%type left_hand_expr_no_fn { Expression * }

left_hand_expr_no_fn(A) ::= new_expr_no_fn(B).
{
    A = B;
}

left_hand_expr_no_fn(A) ::= call_expr_no_fn(B).
{
    A = B;
}

/* Rule 'postfix_expr' */
%type postfix_expr { Expression * }

postfix_expr(A) ::= left_hand_expr(B).
{
    A = B;
}

postfix_expr(A) ::= left_hand_expr(B) INCREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::INCREMENT);
    A->element(B, C);

    delete C;
}

postfix_expr(A) ::= left_hand_expr(B) DECREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::DECREMENT);
    A->element(B, C);

    delete C;
}

/* Rule 'postfix_expr_no_fn' */
%type postfix_expr_no_fn { Expression * }

postfix_expr_no_fn(A) ::= left_hand_expr_no_fn(B).
{
    A = B;
}

postfix_expr_no_fn(A) ::= left_hand_expr_no_fn(B) INCREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::INCREMENT);
    A->element(B, C);

    delete C;
}

postfix_expr_no_fn(A) ::= left_hand_expr_no_fn(B) DECREMENT(C).
{
    A = new expr::Postfix(B, expr::Postfix::OpType::DECREMENT);
    A->element(B, C);

    delete C;
}

/* Rule 'unary_expr' */
%type unary_expr { Expression * }

unary_expr(A) ::= postfix_expr(B).
{
    A = B;
}

unary_expr(A) ::= DELETE(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DELETE);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= VOID(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::VOID);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= TYPEOF(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::TYPEOF);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= INCREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INCREMENT);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= DECREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DECREMENT);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= PLUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::PLUS);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= MINUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::MINUS);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= INV(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INV);
    A->element(B, C);

    delete B;
}

unary_expr(A) ::= NOT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::NOT);
    A->element(B, C);

    delete B;
}

/* Rule 'unary_expr_no_fn' */
%type unary_expr_no_fn { Expression * }

unary_expr_no_fn(A) ::= postfix_expr_no_fn(B).
{
    A = B;
}

unary_expr_no_fn(A) ::= DELETE(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DELETE);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= VOID(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::VOID);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= TYPEOF(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::TYPEOF);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= INCREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INCREMENT);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= DECREMENT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::DECREMENT);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= PLUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::PLUS);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= MINUS(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::MINUS);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= INV(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::INV);
    A->element(B, C);

    delete B;
}

unary_expr_no_fn(A) ::= NOT(B) unary_expr(C).
{
    A = new expr::Unary(C, expr::Unary::OpType::NOT);
    A->element(B, C);

    delete B;
}

/* Rule 'mul_expr' */
%type mul_expr { Expression * }

mul_expr(A) ::= unary_expr(B).
{
    A = B;
}

mul_expr(A) ::= mul_expr(B) MUL(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MUL);
    A->element(B, C);

    delete D;
}

mul_expr(A) ::= mul_expr(B) DIV(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::DIV);
    A->element(B, C);

    delete D;
}

mul_expr(A) ::= mul_expr(B) MOD(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MOD);
    A->element(B, C);

    delete D;
}

/* Rule 'mul_expr_no_fn' */
%type mul_expr_no_fn { Expression * }

mul_expr_no_fn(A) ::= unary_expr_no_fn(B).
{
    A = B;
}

mul_expr_no_fn(A) ::= mul_expr_no_fn(B) MUL(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MUL);
    A->element(B, C);

    delete D;
}

mul_expr_no_fn(A) ::= mul_expr_no_fn(B) DIV(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::DIV);
    A->element(B, C);

    delete D;
}

mul_expr_no_fn(A) ::= mul_expr_no_fn(B) MOD(D) unary_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MOD);
    A->element(B, C);

    delete D;
}

/* Rule 'add_expr' */
%type add_expr { Expression * }

add_expr(A) ::= mul_expr(B).
{
    A = B;
}

add_expr(A) ::= add_expr(B) PLUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::PLUS);
    A->element(B, C);

    delete D;
}

add_expr(A) ::= add_expr(B) MINUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MINUS);
    A->element(B, C);

    delete D;
}

/* Rule 'add_expr_no_fn' */
%type add_expr_no_fn { Expression * }

add_expr_no_fn(A) ::= mul_expr_no_fn(B).
{
    A = B;
}

add_expr_no_fn(A) ::= add_expr_no_fn(B) PLUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::PLUS);
    A->element(B, C);

    delete D;
}

add_expr_no_fn(A) ::= add_expr_no_fn(B) MINUS(D) mul_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::MINUS);
    A->element(B, C);

    delete D;
}

/* Rule 'shift_expr' */
%type shift_expr { Expression * }

shift_expr(A) ::= add_expr(B).
{
    A = B;
}

shift_expr(A) ::= shift_expr(B) LEFT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LEFT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr(A) ::= shift_expr(B) RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr(A) ::= shift_expr(B) ZERO_RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::ZERO_RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

/* Rule 'shift_expr_no_fn' */
%type shift_expr_no_fn { Expression * }

shift_expr_no_fn(A) ::= add_expr_no_fn(B).
{
    A = B;
}

shift_expr_no_fn(A) ::= shift_expr_no_fn(B) LEFT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LEFT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr_no_fn(A) ::= shift_expr_no_fn(B) RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

shift_expr_no_fn(A) ::= shift_expr_no_fn(B) ZERO_RIGHT_SHIFT(D) add_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::ZERO_RIGHT_SHIFT);
    A->element(B, C);

    delete D;
}

/* Rule 'rel_expr' */
%type rel_expr { Expression * }

rel_expr(A) ::= shift_expr(B).
{
    A = B;
}

rel_expr(A) ::= rel_expr(B) LESSER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) GREATER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) LESSER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) GREATER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) INSTANCEOF(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::INSTANCEOF);
    A->element(B, C);

    delete D;
}

rel_expr(A) ::= rel_expr(B) IN(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::IN);
    A->element(B, C);

    delete D;
}

/* Rule 'rel_expr_no_fn' */
%type rel_expr_no_fn { Expression * }

rel_expr_no_fn(A) ::= shift_expr_no_fn(B).
{
    A = B;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) LESSER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) GREATER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) LESSER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) GREATER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) INSTANCEOF(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::INSTANCEOF);
    A->element(B, C);

    delete D;
}

rel_expr_no_fn(A) ::= rel_expr_no_fn(B) IN(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::IN);
    A->element(B, C);

    delete D;
}

/* Rule 'rel_expr_no_in' */
%type rel_expr_no_in { Expression * }

rel_expr_no_in(A) ::= shift_expr(B).
{
    A = B;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) LESSER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) GREATER(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) LESSER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LESSER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) GREATER_EQ(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::GREATER_EQ_THAN);
    A->element(B, C);

    delete D;
}

rel_expr_no_in(A) ::= rel_expr_no_in(B) INSTANCEOF(D) shift_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::INSTANCEOF);
    A->element(B, C);

    delete D;
}

/* Rule 'eq_expr' */
%type eq_expr { Expression * }

eq_expr(A) ::= rel_expr(B).
{
    A = B;
}

eq_expr(A) ::= eq_expr(B) EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr(A) ::= eq_expr(B) NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::NOT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr(A) ::= eq_expr(B) STRICT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr(A) ::= eq_expr(B) STRICT_NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_NOT_EQUAL);
    A->element(B, C);

    delete D;
}

/* Rule 'eq_expr_no_fn' */
%type eq_expr_no_fn { Expression * }

eq_expr_no_fn(A) ::= rel_expr_no_fn(B).
{
    A = B;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::NOT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) STRICT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_fn(A) ::= eq_expr_no_fn(B) STRICT_NOT_EQUAL(D) rel_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_NOT_EQUAL);
    A->element(B, C);

    delete D;
}

/* Rule 'eq_expr_no_in' */
%type eq_expr_no_in { Expression * }

eq_expr_no_in(A) ::= rel_expr_no_in(B).
{
    A = B;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) NOT_EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::NOT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) STRICT_EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_EQUAL);
    A->element(B, C);

    delete D;
}

eq_expr_no_in(A) ::= eq_expr_no_in(B) STRICT_NOT_EQUAL(D) rel_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::STRICT_NOT_EQUAL);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_and_expr' */
%type bit_and_expr { Expression * }

bit_and_expr(A) ::= eq_expr(B).
{
    A = B;
}

bit_and_expr(A) ::= bit_and_expr(B) BITWISE_AND(D) eq_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_and_expr_no_fn' */
%type bit_and_expr_no_fn { Expression * }

bit_and_expr_no_fn(A) ::= eq_expr_no_fn(B).
{
    A = B;
}

bit_and_expr_no_fn(A) ::= bit_and_expr_no_fn(B) BITWISE_AND(D) eq_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_and_expr_no_in' */
%type bit_and_expr_no_in { Expression * }

bit_and_expr_no_in(A) ::= eq_expr_no_in(B).
{
    A = B;
}

bit_and_expr_no_in(A) ::= bit_and_expr_no_in(B) BITWISE_AND(D) eq_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_xor_expr' */
%type bit_xor_expr { Expression * }

bit_xor_expr(A) ::= bit_and_expr(B).
{
    A = B;
}

bit_xor_expr(A) ::= bit_xor_expr(B) BITWISE_XOR(D) bit_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_XOR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_xor_expr_no_fn' */
%type bit_xor_expr_no_fn { Expression * }

bit_xor_expr_no_fn(A) ::= bit_and_expr_no_fn(B).
{
    A = B;
}

bit_xor_expr_no_fn(A) ::= bit_xor_expr_no_fn(B) BITWISE_XOR(D) bit_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_XOR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_xor_expr_no_in' */
%type bit_xor_expr_no_in { Expression * }

bit_xor_expr_no_in(A) ::= bit_and_expr_no_in(B).
{
    A = B;
}

bit_xor_expr_no_in(A) ::= bit_xor_expr_no_in(B) BITWISE_XOR(D) bit_and_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_XOR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_or_expr' */
%type bit_or_expr { Expression * }

bit_or_expr(A) ::= bit_xor_expr(B).
{
    A = B;
}

bit_or_expr(A) ::= bit_or_expr(B) BITWISE_OR(D) bit_xor_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_or_expr_no_fn' */
%type bit_or_expr_no_fn { Expression * }

bit_or_expr_no_fn(A) ::= bit_xor_expr_no_fn(B).
{
    A = B;
}

bit_or_expr_no_fn(A) ::= bit_or_expr_no_fn(B) BITWISE_OR(D) bit_xor_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'bit_or_expr_no_in' */
%type bit_or_expr_no_in { Expression * }

bit_or_expr_no_in(A) ::= bit_xor_expr_no_in(B).
{
    A = B;
}

bit_or_expr_no_in(A) ::= bit_or_expr_no_in(B) BITWISE_OR(D) bit_xor_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::BIT_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_and_expr' */
%type logic_and_expr { Expression * }

logic_and_expr(A) ::= bit_or_expr(B).
{
    A = B;
}

logic_and_expr(A) ::= logic_and_expr(B) LOGIC_AND(D) bit_or_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_and_expr_no_fn' */
%type logic_and_expr_no_fn { Expression * }

logic_and_expr_no_fn(A) ::= bit_or_expr_no_fn(B).
{
    A = B;
}

logic_and_expr_no_fn(A) ::= logic_and_expr_no_fn(B) LOGIC_AND(D) bit_or_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_and_expr_no_in' */
%type logic_and_expr_no_in { Expression * }

logic_and_expr_no_in(A) ::= bit_or_expr_no_in(B).
{
    A = B;
}

logic_and_expr_no_in(A) ::= logic_and_expr_no_in(B) LOGIC_AND(D) bit_or_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_AND);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_or_expr' */
%type logic_or_expr { Expression * }

logic_or_expr(A) ::= logic_and_expr(B).
{
    A = B;
}

logic_or_expr(A) ::= logic_or_expr(B) LOGIC_OR(D) logic_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_or_expr_no_fn' */
%type logic_or_expr_no_fn { Expression * }

logic_or_expr_no_fn(A) ::= logic_and_expr_no_fn(B).
{
    A = B;
}

logic_or_expr_no_fn(A) ::= logic_or_expr_no_fn(B) LOGIC_OR(D) logic_and_expr(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'logic_or_expr_no_in' */
%type logic_or_expr_no_in { Expression * }

logic_or_expr_no_in(A) ::= logic_and_expr_no_in(B).
{
    A = B;
}

logic_or_expr_no_in(A) ::= logic_or_expr_no_in(B) LOGIC_OR(D) logic_and_expr_no_in(C).
{
    A = new expr::Binary(B, C, expr::Binary::OpType::LOGIC_OR);
    A->element(B, C);

    delete D;
}

/* Rule 'cond_expr' */
%type cond_expr { Expression * }

cond_expr(A) ::= logic_or_expr(B).
{
    A = B;
}

cond_expr(A) ::= logic_or_expr(B) QUESTION(E) assign_expr(C) COLON(F) assign_expr(D).
{
    A = new expr::Condition(B, C, D);
    A->element(B, D);

    delete E;
    delete F;
}

/* Rule 'cond_expr_no_fn' */
%type cond_expr_no_fn { Expression * }

cond_expr_no_fn(A) ::= logic_or_expr_no_fn(B).
{
    A = B;
}

cond_expr_no_fn(A) ::= logic_or_expr_no_fn(B) QUESTION(E) assign_expr(C) COLON(F) assign_expr(D).
{
    A = new expr::Condition(B, C, D);
    A->element(B, D);

    delete E;
    delete F;
}

/* Rule 'cond_expr_no_in' */
%type cond_expr_no_in { Expression * }

cond_expr_no_in(A) ::= logic_or_expr_no_in(B).
{
    A = B;
}

cond_expr_no_in(A) ::= logic_or_expr_no_in(B) QUESTION(E) assign_expr(C) COLON(F) assign_expr_no_in(D).
{
    A = new expr::Condition(B, C, D);
    A->element(B, D);

    delete E;
    delete F;
}

/* Rule 'assign_expr' */
%type assign_expr { Expression * }

assign_expr(A) ::= cond_expr(B).
{
    A = B;
}

assign_expr(A) ::= left_hand_expr(B) assign_op(C) assign_expr(D).
{
    A = new expr::Assign(B, D, C);
    A->element(B, D);
}

/* Rule 'assign_expr_no_fn' */
%type assign_expr_no_fn { Expression * }

assign_expr_no_fn(A) ::= cond_expr_no_fn(B).
{
    A = B;
}

assign_expr_no_fn(A) ::= left_hand_expr_no_fn(B) assign_op(C) assign_expr(D).
{
    A = new expr::Assign(B, D, C);
    A->element(B, D);
}

/* Rule 'assign_expr_no_in' */
%type assign_expr_no_in { Expression * }

assign_expr_no_in(A) ::= cond_expr_no_in(B).
{
    A = B;
}

assign_expr_no_in(A) ::= left_hand_expr(B) assign_op(C) assign_expr_no_in(D).
{
    A = new expr::Assign(B, D, C);
    A->element(B, D);
}

/* Rule 'assign_op' */
%type assign_op { expr::Assign::OpType }

assign_op(A) ::= ASSIGN(B).
{
    A = expr::Assign::OpType::SIMPLE;

    delete B;
}

assign_op(A) ::= MUL_ASSIGN(B).
{
    A = expr::Assign::OpType::MUL;

    delete B;
}

assign_op(A) ::= DIV_ASSIGN(B).
{
    A = expr::Assign::OpType::DIV;

    delete B;
}

assign_op(A) ::= MOD_ASSIGN(B).
{
    A = expr::Assign::OpType::MOD;

    delete B;
}

assign_op(A) ::= PLUS_ASSIGN(B).
{
    A = expr::Assign::OpType::PLUS;

    delete B;
}

assign_op(A) ::= MINUS_ASSIGN(B).
{
    A = expr::Assign::OpType::MINUS;

    delete B;
}

assign_op(A) ::= LEFT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::LEFT_SHIFT;

    delete B;
}

assign_op(A) ::= RIGHT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::RIGHT_SHIFT;

    delete B;
}

assign_op(A) ::= ZERO_RIGHT_SHIFT_ASSIGN(B).
{
    A = expr::Assign::OpType::ZERO_RIGHT_SHIFT;

    delete B;
}

assign_op(A) ::= BITWISE_AND_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_AND;

    delete B;
}

assign_op(A) ::= BITWISE_XOR_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_XOR;

    delete B;
}

assign_op(A) ::= BITWISE_OR_ASSIGN(B).
{
    A = expr::Assign::OpType::BIT_OR;

    delete B;
}

/* Rule 'expr' */
%type expr { Expression * }

expr(A) ::= assign_expr(B).
{
    A = B;
}

expr ::= expr COMMA(A) assign_expr.
{
    delete A;
}

/* Rule 'expr_no_fn' */
%type expr_no_fn { Expression * }

expr_no_fn(A) ::= assign_expr_no_fn(B).
{
    A = B;
}

expr_no_fn ::= expr_no_fn COMMA(A) assign_expr.
{
    delete A;
}

/* Rule 'expr_no_in' */
%type expr_no_in { Expression * }

expr_no_in(A) ::= assign_expr_no_in(B).
{
    A = B;
}

expr_no_in ::= expr_no_in COMMA(A) assign_expr_no_in.
{
    delete A;
}

/* Rule 'literal' */
%type literal { Expression * }

literal(A) ::= LIT_NULL(B).
{
    A = new expr::literal::Null();
    A->element(B);

    delete B;
}

literal(A) ::= LIT_UNDEFINED(B).
{
    A = new expr::literal::Undefined();
    A->element(B);

    delete B;
}

literal(A) ::= LIT_TRUE(B).
{
    A = new expr::literal::Boolean(true);
    A->element(B);

    delete B;
}

literal(A) ::= LIT_FALSE(B).
{
    A = new expr::literal::Boolean(false);
    A->element(B);

    delete B;
}

literal(A) ::= NUMBER(B).
{
    A = new expr::literal::Number(B->text());
    A->element(B);

    delete B;
}

literal(A) ::= STRING(B).
{
    A = new expr::literal::String(B->text());
    A->element(B);

    delete B;
}

literal(A) ::= REGEXP(B).
{
    A = new expr::literal::Regexp(B->text());
    A->element(B);

    delete B;
}

/* Rule 'array' */
%type array { expr::Array * }

array(A) ::= LBRACKET(B) RBRACKET(C).
{
    A = new expr::Array();

    delete B;
    delete C;
}

array(A) ::= LBRACKET(C) array_elision(B) RBRACKET(D).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete C;
    delete D;
}

array(A) ::= LBRACKET(C) array_element_list(B) RBRACKET(D).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete C;
    delete D;
}

array(A) ::= LBRACKET(C) array_element_list(B) COMMA(D) RBRACKET(E).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete C;
    delete D;
    delete E;
}

array(A) ::= LBRACKET(D) array_element_list(B) COMMA(E) array_elision(C) RBRACKET(F).
{
    A = new expr::Array();

    for (auto it = B->begin(); it != B->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    delete D;
    delete E;
    delete F;
}

/* Rule 'array_elision' */
%type array_elision { std::vector<std::unique_ptr<Expression>> * }

array_elision(A) ::= COMMA(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(nullptr);

    delete B;
}

array_elision(A) ::= array_elision(B) COMMA(C).
{
    A = B;
    A->push_back(nullptr);

    delete C;
}

/* Rule 'array_element_list' */
%type array_element_list { std::vector<std::unique_ptr<Expression>> * }

array_element_list(A) ::= assign_expr(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(std::unique_ptr<Expression>(B));
}

array_element_list(A) ::= array_elision(B) assign_expr(C).
{
    A = B;
    A->push_back(std::unique_ptr<Expression>(C));
}

array_element_list(A) ::= array_element_list(B) COMMA(D) assign_expr(C).
{
    A = B;
    A->push_back(std::unique_ptr<Expression>(C));

    delete D;
}

array_element_list(A) ::= array_element_list(B) COMMA(D) array_elision(C) assign_expr.
{
    A = B;

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->push_back(std::move(*it));
    }

    delete D;
}

/* Rule 'object' */
%type object { expr::Object * }

object ::= LBRACE(A) RBRACE(B).
{
    delete A;
    delete B;
}

object ::= LBRACE(A) object_properties RBRACE(B).
{
    delete A;
    delete B;
}

object ::= LBRACE(A) object_properties COMMA(B) RBRACE(C).
{
    delete A;
    delete B;
    delete C;
}

/* Rule 'object_properties' */
%type object_properties { std::vector<std::unique_ptr<expr::object::Property>> * }

object_properties(A) ::= object_property(B).
{
    A = new std::vector<std::unique_ptr<expr::object::Property>>();
    A->push_back(std::unique_ptr<expr::object::Property>(B));
}

object_properties(A) ::= object_properties(B) COMMA(D) object_property(C).
{
    A = B;
    A->push_back(std::unique_ptr<expr::object::Property>(C));

    delete D;
}

/* Rule 'object_property' */
%type object_property { expr::object::Property * }

object_property(A) ::= object_property_name(B) COLON(D) assign_expr(C).
{
    A = new expr::object::Property();
    A->key(nullptr);
    A->value(nullptr);
    A->element(B, C);

    delete D;
}

object_property ::= GET(A) object_property_name LPAREN(B) RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

object_property ::= SET(A) object_property_name LPAREN(B) object_property_set_params RPAREN(C) LBRACE(D) function_body RBRACE(E).
{
    delete A;
    delete B;
    delete C;
    delete D;
    delete E;
}

/* Rule 'object_property_name' */
%type object_property_name { Expression * }

object_property_name(A) ::= IDENT(B).
{
    A = new expr::Ident(B->text());
    A->element(B);

    delete B;
}

object_property_name(A) ::= STRING(B).
{
    A = new expr::literal::String(B->text());
    A->element(B);

    delete B;
}

object_property_name(A) ::= NUMBER(B).
{
    A = new expr::literal::Number(B->text());
    A->element(B);

    delete B;
}

/* Rule 'object_property_set_params' */
%type object_property_set_params { std::vector<std::string> * }

object_property_set_params(A) ::= IDENT(B).
{
    A = new std::vector<std::string>();
    A->push_back(B->text());

    delete B;
}

/* Rule 'arguments' */
%type arguments { args::Arguments * }

arguments(A) ::= LPAREN(B) RPAREN(C).
{
    A = new args::Arguments();
    A->element(B, C);

    delete B;
    delete C;
}

arguments(A) ::= LPAREN(B) arguments_list(C) RPAREN(D).
{
    A = new args::Arguments();

    for (auto it = C->begin(); it != C->end(); ++it)
    {
        A->elements().push_back(std::move(*it));
    }

    A->element(B, D);

    delete B;
    delete D;
}

/* Rule 'arguments_list' */
%type arguments_list { std::vector<std::unique_ptr<Expression>> * }

arguments_list(A) ::= assign_expr(B).
{
    A = new std::vector<std::unique_ptr<Expression>>();
    A->push_back(std::unique_ptr<Expression>(B));
}

arguments_list(A) ::= arguments_list(B) COMMA(D) assign_expr(C).
{
    A = B;
    A->push_back(std::unique_ptr<Expression>(C));

    delete D;
}

%token_prefix       ECMA_LEXEME_TYPE_
%token_type         { lex::Lexeme * }
%extra_argument     { parser::Parser *parser }
%name               EcmaParse
%start_symbol       program

%include {
    #include <cassert>
    #include <cstdio>
    #include <vector>
    #include <string>
    #include "ecma/lex/lexeme.h"
    #include "ecma/parser/parser.h"
    #include "ecma/parser/exception.h"

    #include "ecma/ast/ast.h"

    using namespace ecma;
}

%syntax_error {
    int n = sizeof(yyTokenName) / sizeof(*yyTokenName);
    for (int i = 0; i < n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            parser->errors().push_back(yyTokenName[i]);
        }
    }
    throw parser::Exception("Unexpected token", *parser->lexeme(), parser->errors());
}

%token_destructor
{
    delete $$;
}

%right If.
%left Else.

%left Do In For New Try Var Case Null This True With Break Catch False While Extern.
%left Return Switch TypeOf Default Finally Continue Function Undefined InstanceOf.

%left Plus Minus Mul Div Mod.

%left Assign PlusAssign MinusAssign MulAssign DivAssign ModAssign.

%left RightShiftAssign BinaryAndAssign BinaryOrAssign XorAssign.

%left Greater GreaterOrEqual Lesser LesserOrEqual Equal NotEqual Identity NotIdentity.

%left Not Inv Incrementation Decrementation.

%left LogicalOr LogicalAnd BitwiseOr BitwiseAnd BitwiseXor.

%left LeftShift RightShift.

%left LParen LBracket LBrace.
%left RParen RBracket RBrace.

%left QuestionMark Dot.

%left Semicolon Colon Comma.

%left Identifier Integer Double String.

/* Level 0 */

program ::= source(A). { parser->program(A); }

/* Level 1 */

%type source { ast::stmt::Block * }
source(A) ::= source_end(B). { A = new ast::stmt::Block(); if (B) A->statements().push_back(B); }
source(A) ::= source_elements(B) source_end(C). { A = B; if (C) A->statements().push_back(C); }

    %type source_elements { ast::stmt::Block * }
    source_elements(A) ::= source_element(B). { A = new ast::stmt::Block(); A->statements().push_back(B); }
    source_elements(A) ::= source_elements(B) source_element(C). { A = B; A->statements().push_back(C); }

    %type source_end { ast::Statement * }
    source_end(A) ::= . { A = nullptr; }
    source_end(A) ::= openstatement(B). { A = B; }

/* Level 2 */

%type source_element { ast::Statement * }
source_element(A) ::= function_declaration(B). { A = B; }
source_element(A) ::= statement(B). { A = B; }

/* Level 3 */

%type function_declaration { ast::Statement * }
function_declaration(A) ::= Function Identifier(B) LParen RParen LBrace source(C) RBrace. { A = new ast::stmt::decl::Function(*B, new ast::expr::literal::Function(nullptr, C)); delete B; }
function_declaration(A) ::= Function Identifier(B) LParen function_params(C) RParen LBrace source(D) RBrace. { A = new ast::stmt::decl::Function(*B, new ast::expr::literal::Function(C, D)); delete B; }

%type statement { ast::Statement * }
statement(A) ::= block(B). { A = B; }
statement(A) ::= varstatement(B) Semicolon. { A = B; }
statement(A) ::= emptystatement. { A = nullptr; }
statement(A) ::= externstatement(B). { A = B; }
statement(A) ::= exprstatement(B) Semicolon. { A = B; }
statement(A) ::= iterstatement(B). { A = B; }
statement(A) ::= ifstatement(B). { A = B; }
statement(A) ::= contstatement(B) Semicolon. { A = B; }
statement(A) ::= breakstatement(B) Semicolon. { A = B; }
statement(A) ::= returnstatement(B) Semicolon. { A = B; }
statement(A) ::= withstatement(B). { A = B; }
statement(A) ::= labelstatement(B). { A = B; }
statement(A) ::= switchstatement(B). { A = B; }
statement(A) ::= throwstatement(B) Semicolon. { A = B; }
statement(A) ::= trystatement(B). { A = B; }

%type openstatement { ast::Statement * }
openstatement(A) ::= varstatement(B). { A = B; }
openstatement(A) ::= exprstatement(B). { A = B; }
openstatement(A) ::= contstatement(B). { A = B; }
openstatement(A) ::= breakstatement(B). { A = B; }
openstatement(A) ::= returnstatement(B). { A = B; }
openstatement(A) ::= throwstatement(B). { A = B; }

/* Level 4 */

%type block { ast::stmt::Block * }
block(A) ::= LBrace statements(B) RBrace. { A = B; }

%type varstatement { ast::stmt::decl::Variables * }
varstatement(A) ::= Var vardecls(B). { A = B; }

%type externstatement { ast::Statement * }
externstatement(A) ::= Extern Identifier(B) Semicolon. { A = new ast::stmt::decl::Function(*B); delete B; }

emptystatement ::= Semicolon.

%type exprstatement { ast::Statement * }
exprstatement(A) ::= top_expression(B). { A = new ast::stmt::Expression(B); }

%type function_params { std::vector<std::string> * }
function_params(A) ::= Identifier(B). { A = new std::vector<std::string>(); A->push_back(*B); delete B; }
function_params(A) ::= function_params(B) Comma Identifier(C). { A = B; A->push_back(*C); delete C; }

%type ifstatement { ast::Statement * }
ifstatement(A) ::= If LParen expression(B) RParen statement(C). { A = new ast::stmt::ctrl::If(B, C); }
ifstatement(A) ::= If LParen expression(B) RParen statement(C) Else statement(D). { A = A = new ast::stmt::ctrl::If(B, C, D); }

%type iterstatement { ast::Statement * }
iterstatement(A) ::= Do statement(B) While LParen expression(C) RParen. { A = new ast::stmt::ctrl::While(true, C, B); }
iterstatement(A) ::= While LParen expression(B) RParen statement(C). { A = new ast::stmt::ctrl::While(false, B, C); }
iterstatement(A) ::= For LParen expressionsNoIn(B) Semicolon expressions(C) Semicolon expressions(D) RParen statement(E). { A = new ast::stmt::ctrl::For(B, C, D, E); }
iterstatement(A) ::= For LParen Var vardeclsNoIn(B) Semicolon expressions(C) Semicolon expressions(D) RParen statement(E). { A = new ast::stmt::ctrl::For(B, C, D, E); }
iterstatement(A) ::= For LParen Identifier(B) In expression(C) RParen statement(D). { A = new ast::stmt::ctrl::ForIn(false, *B, C, D); delete B; }
iterstatement(A) ::= For LParen Var Identifier(B) In expression(C) RParen statement(D). { A = new ast::stmt::ctrl::ForIn(true, *B, C, D); delete B; }

    %type expressionsNoIn { ast::Expression * }
    expressionsNoIn(A) ::= expressionNoIn(B). { A = B; }
    expressionsNoIn(A) ::= . { A = nullptr; }

    %type expressions { ast::Expression * }
    expressions(A) ::= expression(B). { A = B; }
    expressions(A) ::= . { A = nullptr; }

%type contstatement { ast::Statement * }
contstatement(A) ::= Continue. { A = new ast::stmt::Continue(""); }
contstatement(A) ::= Continue Identifier(B). { A = new ast::stmt::Continue(*B); delete B; }

%type breakstatement { ast::Statement * }
breakstatement(A) ::= Break. { A = new ast::stmt::Break(""); }
breakstatement(A) ::= Break Identifier(B). { A = new ast::stmt::Break(*B); delete B; }

%type returnstatement { ast::Statement * }
returnstatement(A) ::= Return. { A = new ast::stmt::Return(); }
returnstatement(A) ::= Return expression(B). { A = new ast::stmt::Return(B); }

%type withstatement { ast::Statement * }
withstatement(A) ::= With LParen expression(B) RParen statement(C). { A = new ast::stmt::With(B, C); }

%type labelstatement { ast::Statement * }
labelstatement(A) ::= Identifier(B) Colon statement(C). { A = new ast::stmt::Label(*B, C); delete B; }

%type switchstatement { ast::Statement * }
switchstatement(A) ::= Switch LParen expression(B) RParen caseblock(C). { A = new ast::stmt::ctrl::Switch(B, C); }

%type throwstatement { ast::Statement * }
throwstatement(A) ::= Throw expression(B). { A = new ast::stmt::Throw(B); }

%type trystatement { ast::Statement * }
trystatement(A) ::= Try block(B) catch(C). { A = new ast::stmt::ctrl::Try(B, C); }
trystatement(A) ::= Try block(B) finally(C). { A = new ast::stmt::ctrl::Try(B, nullptr, C); }
trystatement(A) ::= Try block(B) catch(C) finally(D). { A = new ast::stmt::ctrl::Try(B, C, D); }

/* Level 5 */

%type caseblock { std::vector<ast::stmt::ctrl::Switch::Case *> * }
caseblock(A) ::= LBrace RBrace. { A = nullptr; }
caseblock(A) ::= LBrace caseclauses(B) RBrace. { A = B; }

%type catch { ast::stmt::ctrl::Try::Catch * }
catch(A) ::= Catch LParen Identifier(B) RParen block(C). { A = new ast::stmt::ctrl::Try::Catch(*B, C); delete B; }

%type expression { ast::Expression * }
expression(A) ::= assignexpression(B). { A = B; }
expression(A) ::= functionexpression(B). { A = B; }
expression(A) ::= expression Comma assignexpression. { A = nullptr; }

%type top_expression { ast::Expression * }
top_expression(A) ::= assignexpression(B). { A = B; }
top_expression(A) ::= top_expression Comma assignexpression. { A = nullptr; }

%type expressionNoIn { ast::Expression * }
expressionNoIn(A) ::= assignexpressionNoIn(B). { A = B; }
expressionNoIn(A) ::= expressionNoIn Comma assignexpressionNoIn. { A = nullptr; }

%type finally { ast::stmt::Block * }
finally(A) ::= Finally block(B). { A = B; }

%type leftexpression { ast::Expression * }
leftexpression(A) ::= newexpression(B). { A = B; }
leftexpression(A) ::= callexpression(B). { A = B; }
leftexpression(A) ::= externexpression(B). { A = B; }

%type statements { ast::stmt::Block * }
statements(A) ::= statement(B). { A = new ast::stmt::Block(); A->statements().push_back(B); }
statements(A) ::= statements(B) statement(C). { B->statements().push_back(C); A = B; }

%type vardecls { ast::stmt::decl::Variables * }
vardecls(A) ::= vardecl(B). { A = new ast::stmt::decl::Variables(); A->vars().push_back(B); }
vardecls(A) ::= vardecls(B) Comma vardecl(C). { B->vars().push_back(C); A = B; }

%type vardeclsNoIn { ast::stmt::decl::Variables * }
vardeclsNoIn(A) ::= vardeclNoIn(B). { A = new ast::stmt::decl::Variables(); A->vars().push_back(B); }
vardeclsNoIn(A) ::= vardeclsNoIn(B) Comma vardeclNoIn(C). { B->vars().push_back(C); A = B; }

%type vardeclNoIn { ast::stmt::decl::Variables::Variable * }
vardeclNoIn(A) ::= Identifier(B). { A = new ast::stmt::decl::Variables::Variable(*B); delete B; }
vardeclNoIn(A) ::= Identifier(B) Assign assignexpressionNoIn(C). { A = new ast::stmt::decl::Variables::Variable(*B, C); delete B; }

/* Level 6 */

%type assignexpression { ast::Expression * }
assignexpression(A) ::= condexpression(B). { A = B; }
assignexpression(A) ::= leftexpression(B) assignop(C) down_expression(D). { A = new ast::expr::Assign(C, B, D); }

%type assignexpressionNoIn { ast::Expression * }
assignexpressionNoIn(A) ::= condexpressionNoIn(B). { A = B; }
assignexpressionNoIn(A) ::= leftexpression(B) assignop(C) down_expressionNoIn(D). { A = new ast::expr::Assign(C, B, D); }

%type callexpression { ast::Expression * }
callexpression(A) ::= memberexpression(B) arguments(C). { A = new ast::expr::Call(B, C); }
callexpression(A) ::= callexpression(B) arguments(C). { A = new ast::expr::Call(B, C); }
callexpression(A) ::= callexpression(B) LBracket expression(C) RBracket. { A = new ast::expr::Index(B, C); }
callexpression(A) ::= callexpression(B) Dot Identifier(C). { A = new ast::expr::Member(B, *C); delete C; }

%type caseclauses { std::vector<ast::stmt::ctrl::Switch::Case *> * }
caseclauses(A) ::= caseclause(B). { A = new std::vector<ast::stmt::ctrl::Switch::Case *>(); A->push_back(B); }
caseclauses(A) ::= caseclauses(B) caseclause(C). { A = B; A->push_back(C); }

%type newexpression { ast::Expression * }
newexpression(A) ::= memberexpression(B). { A = B; }
// newexpression(A) ::= New newexpression. { A = nullptr; }

%type vardecl { ast::stmt::decl::Variables::Variable * }
vardecl(A) ::= Identifier(B). { A = new ast::stmt::decl::Variables::Variable(*B); delete B; }
vardecl(A) ::= Identifier(B) Assign down_expression(C). { A = new ast::stmt::decl::Variables::Variable(*B, C); delete B; }

%type externexpression { ast::Expression * }
externexpression(A) ::= Extern Identifier(B). { A = new ast::expr::Extern(*B); delete B; }

/* Level 7 */

%type arguments { std::vector<ast::Expression *> * }
arguments(A) ::= LParen RParen. { A = nullptr; }
arguments(A) ::= LParen arguments_list(B) RParen. { A = B; }

%type assignop { ast::expr::Assign::Type }
assignop(A) ::= Assign. { A = ast::expr::Assign::Type::Assign; }
assignop(A) ::= PlusAssign. { A = ast::expr::Assign::Type::PlusAssign; }
assignop(A) ::= MinusAssign. { A = ast::expr::Assign::Type::MinusAssign; }
assignop(A) ::= MulAssign. { A = ast::expr::Assign::Type::MulAssign; }
assignop(A) ::= DivAssign. { A = ast::expr::Assign::Type::DivAssign; }
assignop(A) ::= ModAssign. { A = ast::expr::Assign::Type::ModAssign; }
assignop(A) ::= RightShiftAssign. { A = ast::expr::Assign::Type::RightShiftAssign; }
assignop(A) ::= BinaryAndAssign. { A = ast::expr::Assign::Type::BinaryAndAssign; }
assignop(A) ::= BinaryOrAssign. { A = ast::expr::Assign::Type::BinaryOrAssign; }
assignop(A) ::= XorAssign. { A = ast::expr::Assign::Type::XorAssign; }

%type caseclause { ast::stmt::ctrl::Switch::Case * }
caseclause(A) ::= Case expression(B) Colon. { A = new ast::stmt::ctrl::Switch::Case(nullptr, B); }
caseclause(A) ::= Case expression(B) Colon statements(C). { A = new ast::stmt::ctrl::Switch::Case(C, B); }
caseclause(A) ::= Default Colon. { A = new ast::stmt::ctrl::Switch::Case(); }
caseclause(A) ::= Default Colon statements(B). { A = new ast::stmt::ctrl::Switch::Case(B); }

%type condexpression { ast::Expression * }
condexpression(A) ::= logical_or_expr(B). { A = B; }
condexpression(A) ::= logical_or_expr(B) QuestionMark assignexpression(C) Colon assignexpression(D). { A = new ast::expr::Conditional(B, C, D); }

%type condexpressionNoIn { ast::Expression * }
condexpressionNoIn(A) ::= logical_or_exprNoIn(B). { A = B; }
condexpressionNoIn(A) ::= logical_or_exprNoIn(B) QuestionMark assignexpressionNoIn(C) Colon assignexpressionNoIn(D). { A = new ast::expr::Conditional(B, C, D); }

%type down_expression { ast::Expression * }
down_expression(A) ::= assignexpression(B). { A = B; }
down_expression(A) ::= functionexpression(B). { A = B; }

%type down_expressionNoIn { ast::Expression * }
down_expressionNoIn(A) ::= assignexpressionNoIn(B). { A = B; }
down_expressionNoIn(A) ::= functionexpression(B). { A = B; }

%type memberexpression { ast::Expression * }
memberexpression(A) ::= primaryexpression(B). { A = B; }
memberexpression(A) ::= memberexpression(B) LBracket expression(C) RBracket. { A = new ast::expr::Index(B, C); }
memberexpression(A) ::= memberexpression(B) Dot Identifier(C). { A = new ast::expr::Member(B, *C); delete C; }
memberexpression(A) ::= New memberexpression(B) arguments(C). { A = new ast::expr::New(B, C); }

/* Level 8 */

%type arguments_list { std::vector<ast::Expression *> * }
arguments_list(A) ::= down_expression(B). { A = new std::vector<ast::Expression *>(); if (B) A->push_back(B); }
arguments_list(A) ::= arguments_list(B) Comma down_expression(C). { A = B; if (C) A->push_back(C); }

%type functionexpression { ast::Expression * }
functionexpression(A) ::= Function func_name LParen RParen LBrace source(B) RBrace. { A = new ast::expr::literal::Function(nullptr, B); }
functionexpression(A) ::= Function func_name LParen function_params(B) RParen LBrace source(C) RBrace. { A = new ast::expr::literal::Function(B, C); }

    func_name ::= .
    func_name ::= Identifier.

%type logical_or_expr { ast::Expression * }
logical_or_expr(A) ::= logical_and_expr(B). { A = B; }
logical_or_expr(A) ::= logical_or_expr(B) LogicalOr logical_and_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalOr, B, C); }

%type logical_or_exprNoIn { ast::Expression * }
logical_or_exprNoIn(A) ::= logical_and_exprNoIn(B). { A = B; }
logical_or_exprNoIn(A) ::= logical_or_exprNoIn(B) LogicalOr logical_and_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalOr, B, C); }

%type primaryexpression { ast::Expression * }
primaryexpression(A) ::= This. { A = new ast::expr::This(); }
primaryexpression(A) ::= Identifier(B). { A = new ast::expr::Identifier(*B); delete B; }
primaryexpression(A) ::= literal(B). { A = B; }
primaryexpression(A) ::= arrayliteral(B). { A = B; }
primaryexpression(A) ::= objectliteral(B). { A = B; }
primaryexpression(A) ::= LParen down_expression(B) RParen. { A = B; }

/* Level 9 */

%type arrayliteral { ast::expr::Array * }
arrayliteral(A) ::= LBracket RBracket. { A = new ast::expr::Array(); }
arrayliteral(A) ::= LBracket element_list(B) RBracket. { A = new ast::expr::Array(B); }

%type literal { ast::Expression * }
literal(A) ::= Null. { A = new ast::expr::literal::Null(); }
literal(A) ::= Undefined. { A = new ast::expr::literal::Undefined(); }
literal(A) ::= True. { A = new ast::expr::literal::Boolean(true); }
literal(A) ::= False. { A = new ast::expr::literal::Boolean(false); }
literal(A) ::= Integer(B). { A = new ast::expr::literal::Integer(*B); delete B; }
literal(A) ::= Double(B). { A = new ast::expr::literal::Double(*B); delete B; }
literal(A) ::= String(B). { A = new ast::expr::literal::String(*B); delete B; }
literal(A) ::= Regex(B). { A = new ast::expr::literal::Regex(*B); delete B; }

%type logical_and_expr { ast::Expression * }
logical_and_expr(A) ::= bitwise_or_expr(B). { A = B; }
logical_and_expr(A) ::= logical_and_expr(B) LogicalAnd bitwise_or_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalAnd, B, C); }

%type logical_and_exprNoIn { ast::Expression * }
logical_and_exprNoIn(A) ::= bitwise_or_exprNoIn(B). { A = B; }
logical_and_exprNoIn(A) ::= logical_and_exprNoIn(B) LogicalAnd bitwise_or_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalAnd, B, C); }

%type objectliteral { ast::expr::Object * }
objectliteral(A) ::= LBrace RBrace. { A = new ast::expr::Object(); }
objectliteral(A) ::= LBrace object_properties(B) RBrace. { A = new ast::expr::Object(B); }

/* Level 10 */

%type bitwise_or_expr { ast::Expression * }
bitwise_or_expr(A) ::= bitwise_xor_expr(B). { A = B; }
bitwise_or_expr(A) ::= bitwise_or_expr(B) BitwiseOr bitwise_xor_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::BitwiseOr, B, C); }

%type bitwise_or_exprNoIn { ast::Expression * }
bitwise_or_exprNoIn(A) ::= bitwise_xor_exprNoIn(B). { A = B; }
bitwise_or_exprNoIn(A) ::= bitwise_or_exprNoIn(B) BitwiseOr bitwise_xor_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::BitwiseOr, B, C); }

%type element_list { std::vector<ast::Expression *> * }
element_list(A) ::= down_expression(B). { A = new std::vector<ast::Expression *>(); A->push_back(B); }
element_list(A) ::= element_list(B) Comma down_expression(C). { A = B; A->push_back(C); }

// elision ::= Comma.
// elision ::= elision Comma.

%type object_properties { std::vector<ast::expr::Object::Property *> * }
object_properties(A) ::= property_key(B) Colon down_expression(C). { A = new std::vector<ast::expr::Object::Property *>(); A->push_back(new ast::expr::Object::Property(B, C)); }
object_properties(A) ::= object_properties(B) Comma property_key(C) Colon down_expression(D). { A = B; A->push_back(new ast::expr::Object::Property(C, D));}

/* Level 11 */

%type bitwise_xor_expr { ast::Expression * }
bitwise_xor_expr(A) ::= bitwise_and_expr(B). { A = B; }
bitwise_xor_expr(A) ::= bitwise_xor_expr(B) BitwiseXor bitwise_and_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalAnd, B, C); }

%type bitwise_xor_exprNoIn { ast::Expression * }
bitwise_xor_exprNoIn(A) ::= bitwise_and_exprNoIn(B). { A = B; }
bitwise_xor_exprNoIn(A) ::= bitwise_xor_exprNoIn(B) BitwiseXor bitwise_and_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalAnd, B, C); }

%type property_key { lex::Lexeme * }
property_key(A) ::= Identifier(B). { A = B; }
property_key(A) ::= String(B). { A = B; }
property_key(A) ::= Integer(B). { A = B; }
property_key(A) ::= Double(B). { A = B; }

/* Level 12 */

%type bitwise_and_expr { ast::Expression * }
bitwise_and_expr(A) ::= equality_expr(B). { A = B; }
bitwise_and_expr(A) ::= bitwise_and_expr(B) BitwiseAnd equality_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalAnd, B, C); }

%type bitwise_and_exprNoIn { ast::Expression * }
bitwise_and_exprNoIn(A) ::= equality_exprNoIn(B). { A = B; }
bitwise_and_exprNoIn(A) ::= bitwise_and_exprNoIn(B) BitwiseAnd equality_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LogicalAnd, B, C); }

/* Level 13 */

%type equality_expr { ast::Expression * }
equality_expr(A) ::= relational_expr(B). { A = B; }
equality_expr(A) ::= equality_expr(B) Equal relational_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Equal, B, C); }
equality_expr(A) ::= equality_expr(B) NotEqual relational_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::NotEqual, B, C); }
equality_expr(A) ::= equality_expr(B) Identity relational_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Identity, B, C); }
equality_expr(A) ::= equality_expr(B) NotIdentity relational_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::NotIdentity, B, C); }

%type equality_exprNoIn { ast::Expression * }
equality_exprNoIn(A) ::= relational_exprNoIn(B). { A = B; }
equality_exprNoIn(A) ::= equality_exprNoIn(B) Equal relational_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Equal, B, C); }
equality_exprNoIn(A) ::= equality_exprNoIn(B) NotEqual relational_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::NotEqual, B, C); }
equality_exprNoIn(A) ::= equality_exprNoIn(B) Identity relational_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Identity, B, C); }
equality_exprNoIn(A) ::= equality_exprNoIn(B) NotIdentity relational_exprNoIn(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::NotIdentity, B, C); }

/* Level 14 */
%type relational_expr { ast::Expression * }
relational_expr(A) ::= shift_expr(B). { A = B; }
relational_expr(A) ::= relational_expr(B) Lesser shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Lesser, B, C); }
relational_expr(A) ::= relational_expr(B) LesserOrEqual shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LesserOrEqual, B, C); }
relational_expr(A) ::= relational_expr(B) Greater shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Greater, B, C); }
relational_expr(A) ::= relational_expr(B) GreaterOrEqual shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::GreaterOrEqual, B, C); }
relational_expr(A) ::= relational_expr(B) InstanceOf shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::InstanceOf, B, C); }
relational_expr(A) ::= relational_expr(B) In shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::In, B, C); }

%type relational_exprNoIn { ast::Expression * }
relational_exprNoIn(A) ::= shift_expr(B). { A = B; }
relational_exprNoIn(A) ::= relational_exprNoIn(B) Lesser shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Lesser, B, C); }
relational_exprNoIn(A) ::= relational_exprNoIn(B) LesserOrEqual shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LesserOrEqual, B, C); }
relational_exprNoIn(A) ::= relational_exprNoIn(B) Greater shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Greater, B, C); }
relational_exprNoIn(A) ::= relational_exprNoIn(B) GreaterOrEqual shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::GreaterOrEqual, B, C); }
relational_exprNoIn(A) ::= relational_exprNoIn(B) InstanceOf shift_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::InstanceOf, B, C); }

/* Level 15 */

%type shift_expr { ast::Expression * }
shift_expr(A) ::= add_expr(B). { A = B; }
shift_expr(A) ::= shift_expr(B) LeftShift add_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::LeftShift, B, C); }
shift_expr(A) ::= shift_expr(B) RightShift add_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::RightShift, B, C); }

/* Level 16 */

%type add_expr { ast::Expression * }
add_expr(A) ::= mul_expr(B). { A = B; }
add_expr(A) ::= add_expr(B) Plus mul_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Plus, B, C); }
add_expr(A) ::= add_expr(B) Minus mul_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Minus, B, C); }

/* Level 17 */

%type mul_expr { ast::Expression * }
mul_expr(A) ::= unary_expr(B). { A = B; }
mul_expr(A) ::= mul_expr(B) Mul unary_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Mul, B, C); }
mul_expr(A) ::= mul_expr(B) Div unary_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Div, B, C); }
mul_expr(A) ::= mul_expr(B) Mod unary_expr(C). { A = new ast::expr::Binary(ast::expr::Binary::Type::Mod, B, C); }

/* Level 18 */

%type unary_expr { ast::Expression * }
unary_expr(A) ::= postfix_expr(B). { A = B; }
unary_expr(A) ::= Not unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::Not, B); }
unary_expr(A) ::= Inv unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::Inv, B); }
unary_expr(A) ::= Plus unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::Plus, B); }
unary_expr(A) ::= Minus unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::Minus, B); }
unary_expr(A) ::= Incrementation unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::PreIncrementation, B); }
unary_expr(A) ::= Decrementation unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::PreDecrementation, B); }
unary_expr(A) ::= TypeOf unary_expr(B). { A = new ast::expr::Unary(ast::expr::Unary::Type::TypeOf, B); }

/* Level 19 */

%type postfix_expr { ast::Expression * }
postfix_expr(A) ::= leftexpression(B). { A = B; }
postfix_expr(A) ::= leftexpression(B) Incrementation. { A = new ast::expr::Unary(ast::expr::Unary::Type::PostIncrementation, B); }
postfix_expr(A) ::= leftexpression(B) Decrementation. { A = new ast::expr::Unary(ast::expr::Unary::Type::PostDecrementation, B); }

%token_prefix       ECMA_LEXEME_TYPE_
%token_type         { lex::Lexeme * }
%extra_argument     { parser::Parser *parser }
%name               EcmaParse

%include {
    #include <cassert>
    #include <cstdio>
    #include <vector>
    #include <string>
    #include "ecma/lex/lexeme.h"
    #include "ecma/parser/parser.h"

    #include "ecma/ast/node.h"
    #include "ecma/ast/expression.h"
    #include "ecma/ast/statement.h"
    #include "ecma/ast/stmt/block.h"

    using namespace ecma;
}

%syntax_error {
    int n = sizeof(yyTokenName) / sizeof(*yyTokenName);
    for (int i = 0; i < n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            parser->errors().push_back(yyTokenName[i]);
        }
    }
    parser->error(true);
}

%left If Var Else Null True False Return Function Undefined.

%left Plus Minus Mul Div Mod.

%left Assign PlusAssign MinusAssign MulAssign DivAssign ModAssign.

%left Greater GreaterOrEqual Lesser LesserOrEqual Equal NotEqual.

%left Not Inv Incrementation Decrementation.

%left LParen RParen LBracket RBracket LBrace RBrace.

%left QuestionMark Dot.

%left Semicolon Colon Comma.

%left Identifier Number String.

program ::= statements(A). { parser->program(A); }

    %type statements { ast::stmt::Block * }
    statements(A) ::= statements(B) statement(C). { if (C) B->statements().push_back(C); A = B; }
    statements(A) ::= . { A = new ast::stmt::Block(); }

        %type statement { ast::Statement * }
        statement(A) ::= Var Identifier Assign Number. { A = nullptr; }

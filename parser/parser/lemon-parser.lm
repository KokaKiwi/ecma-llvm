%token_prefix       ECMA_TOKEN_TYPE_
%token_type         { lex::Token * }
%name               ecma_parse

%include
{
    #include <cassert>
    #include <stdio.h>
    #include "ecma/lex/token.h"

    using namespace ecma;
}

%token_destructor
{
    delete $$;
}

%left INSTANCEOF CONTINUE DEBUGGER FUNCTION DEFAULT FINALLY DELETE RETURN SWITCH TYPEOF BREAK CATCH THROW WHILE CASE ELSE THIS VOID WITH FOR NEW TRY VAR DO IF IN.
%left EXTENDS EXPORT IMPORT CLASS CONST SUPER ENUM.
%left IMPLEMENTS INTERFACE PROTECTED PACKAGE PRIVATE PUBLIC STATIC YIELD LET.
%left ZERO_RIGHT_SHIFT_ASSIGN STRICT_EQUAL STRICT_NOT_EQUAL ZERO_RIGHT_SHIFT LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN LESSER_EQ GREATER_EQ EQUAL NOT_EQUAL INCREMENT DECREMENT LEFT_SHIFT RIGHT_SHIFT LOGIC_AND LOGIC_OR PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET DOT SEMICOLON COMMA QUESTION COLON LESSER GREATER PLUS MINUS MUL MOD DIV BITWISE_AND BITWISE_OR BITWISE_XOR ASSIGN NOT INV.
%left LIT_UNDEFINED NUMBER STRING REGEXP LIT_FALSE IDENT LIT_NULL LIT_TRUE.

/* Rule 'module' */
%start_symbol module

module ::= primary_expr.
{}

/* Rule 'primary_expr' */

primary_expr ::= THIS.
{}

primary_expr ::= IDENT.
{}

primary_expr ::= literal.
{}

primary_expr ::= array.
{}

/* Rule 'assign_expr' */

assign_expr ::= primary_expr.
{}

/* Rule 'literal' */

literal ::= LIT_NULL.
{}

literal ::= LIT_TRUE.
{}

literal ::= LIT_FALSE.
{}

literal ::= NUMBER.
{}

literal ::= STRING.
{}

literal ::= REGEXP.
{}

/* Rule 'array' */

array ::= LBRACKET RBRACKET.
{}

array ::= LBRACKET array_elision RBRACKET.
{}

array ::= LBRACKET array_element_list RBRACKET.
{}

array ::= LBRACKET array_element_list COMMA RBRACKET.
{}

array ::= LBRACKET array_element_list COMMA array_elision RBRACKET.
{}

/* Rule 'array_elision' */

array_elision ::= COMMA.
{}

array_elision ::= array_elision COMMA.
{}

/* Rule 'array_element_list' */

array_element_list ::= assign_expr.
{}

array_element_list ::= array_elision assign_expr.
{}

array_element_list ::= array_element_list COMMA assign_expr.
{}

array_element_list ::= array_element_list COMMA array_elision assign_expr.
{}
